# DeepWiki Q&A with Code Context for Repository: leanprover-community/mathlib4
## Q1
identify the principled, appropriate available and missing API and prerequisites required to prove the below axioms as theorem:

/-
Copyright (c) 2025 Michael R. Douglas, Sarah Hoback. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.

# Nuclear Operators and Nuclear Spaces

Definitions of nuclear operators, Hilbertian seminorms, and nuclear spaces
via Hilbert-Schmidt embeddings. This characterization is adapted to
Schwartz/Fr√©chet spaces where a countable Hilbertian basis is available,
and suffices for the GFF construction via the Minlos theorem.

## Main definitions

- `IsNuclearMap` ‚Äî nuclear operator representation for maps between normed spaces
- `Seminorm.IsHilbertian` ‚Äî seminorms satisfying the parallelogram law
- `Seminorm.innerProd` ‚Äî inner product recovered from a Hilbertian seminorm
- `Seminorm.IsOrthonormalSeq` ‚Äî p-orthonormal finite sequences
- `Seminorm.IsHilbertSchmidtEmbedding` ‚Äî Hilbert-Schmidt condition on inclusions
- `NuclearSpace` ‚Äî nuclear space via Hilbertian seminorms with HS embeddings
- `SchwartzNuclearInclusion` ‚Äî remaining hypothesis packaging Schwartz nuclearity (canonical local Banach inclusions)

## References

- Tr√®ves, "Topological Vector Spaces", Ch. 50-51
- Gel'fand-Vilenkin, "Generalized Functions" Vol. 4, Ch. 3-4
- Reed-Simon, "Methods of Modern Mathematical Physics" Vol. 1, ¬ßV.3
- Pietsch, "Nuclear Locally Convex Spaces"
-/

import Mathlib.Analysis.LocallyConvex.WithSeminorms
import Mathlib.Analysis.Distribution.SchwartzSpace.Deriv

open scoped BigOperators

noncomputable section

/-! ### Nuclear Operators

The hierarchy of operator conditions between normed spaces:
  nuclear (trace-class) ‚äÇ Hilbert-Schmidt ‚äÇ compact
-/

/-- A continuous linear map between normed spaces is **nuclear** if it admits a
    representation T(x) = ‚àë‚Çô (œÜ‚Çô x) ‚Ä¢ y‚Çô where ‚àë‚Çô ‚ÄñœÜ‚Çô‚Äñ ¬∑ ‚Äñy‚Çô‚Äñ < ‚àû. -/
def IsNuclearMap {E F : Type*}
    [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
    [NormedAddCommGroup F] [NormedSpace ‚Ñù F] [CompleteSpace F]
    (T : E ‚ÜíL[‚Ñù] F) : Prop :=
  ‚àÉ (œÜ : ‚Ñï ‚Üí (E ‚ÜíL[‚Ñù] ‚Ñù)) (y : ‚Ñï ‚Üí F),
    Summable (fun n => ‚ÄñœÜ n‚Äñ * ‚Äñy n‚Äñ) ‚àß
    ‚àÄ x, T x = ‚àë' n, (œÜ n x) ‚Ä¢ y n

/-! ### Hilbertian Seminorms -/

/-- A seminorm is **Hilbertian** (comes from an inner product) iff it satisfies
    the parallelogram law: p(x+y)¬≤ + p(x-y)¬≤ = 2(p(x)¬≤ + p(y)¬≤).

    The inner product can be recovered by polarization:
    ‚ü®x,y‚ü©_p = (p(x+y)¬≤ - p(x-y)¬≤) / 4. -/
def Seminorm.IsHilbertian {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    (p : Seminorm ‚Ñù E) : Prop :=
  ‚àÄ x y : E, p (x + y) ^ 2 + p (x - y) ^ 2 = 2 * (p x ^ 2 + p y ^ 2)

/-- The inner product induced by a Hilbertian seminorm via polarization. -/
noncomputable def Seminorm.innerProd {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    (p : Seminorm ‚Ñù E) (x y : E) : ‚Ñù :=
  (p (x + y) ^ 2 - p (x - y) ^ 2) / 4

/-- A finite sequence is **p-orthonormal**: ‚ü®e·µ¢, e‚±º‚ü©_p = Œ¥·µ¢‚±º. -/
def Seminorm.IsOrthonormalSeq {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    (p : Seminorm ‚Ñù E) {n : ‚Ñï} (e : Fin n ‚Üí E) : Prop :=
  ‚àÄ i j, p.innerProd (e i) (e j) = if i = j then 1 else 0

/-! ### Hilbert-Schmidt Embeddings -/

/-- The canonical inclusion √ä_p ‚Üí √ä_q is **Hilbert-Schmidt**: the sum ‚àë q(e‚Çñ)¬≤
    is uniformly bounded over all finite p-orthonormal sequences {e‚Çñ}.

    For diagonal operators with eigenvalues œÉ‚Çñ, this reduces to ‚àë œÉ‚Çñ¬≤ < ‚àû.
    For Schwartz space with Hermite basis and Sobolev norms ‚Äñf‚Äñ_k¬≤ = ‚àë n^{2k} |‚ü®f,h‚Çô‚ü©|¬≤,
    the inclusion from level k+s to level k has eigenvalues n^{-s}, and
    ‚àë n^{-2s} < ‚àû for s > ¬Ω. -/
def Seminorm.IsHilbertSchmidtEmbedding {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    (p q : Seminorm ‚Ñù E) : Prop :=
  q ‚â§ p ‚àß
  ‚àÉ (C : ‚Ñù), ‚àÄ (n : ‚Ñï) (e : Fin n ‚Üí E),
    p.IsOrthonormalSeq e ‚Üí
    ‚àë i, q (e i) ^ 2 ‚â§ C

/-! ### Nuclear Spaces -/

/-- A **nuclear space** is a locally convex space whose topology is generated by a
    countable family of Hilbertian seminorms with Hilbert-Schmidt inclusion maps.

    **Definition**: There exists a family of seminorms {p‚Çñ} such that:
    1. Each p‚Çñ is Hilbertian (comes from an inner product)
    2. The family generates the topology of E
    3. For every k, there exists k' > k such that the inclusion √ä_{k'} ‚Üí √ä_k
       is a Hilbert-Schmidt operator

    **Why this implies nuclearity**: For Fr√©chet spaces, Hilbert-Schmidt inclusions
    at every level imply that the composition of two consecutive inclusions is nuclear
    (trace-class), since HS ‚àò HS = nuclear. This gives the Grothendieck-Pietsch
    characterization.

    **Example (Schwartz space S(‚Ñù·µà))**: Take the Hermite basis {h‚Çô} (eigenfunctions
    of the harmonic oscillator H = -Œî + |x|¬≤) and define:
      ‚Äñf‚Äñ_k¬≤ = ‚àë‚Çô (1+n)^{2k} |‚ü®f, h‚Çô‚ü©|¬≤
    The inclusion from level k+s to level k is diagonal with eigenvalues (1+n)^{-s},
    and ‚àë‚Çô (1+n)^{-2s} < ‚àû for s > ¬Ω.

    **Non-examples**: ‚Ñì^p, L^p, and Banach spaces (except finite-dimensional) are NOT nuclear.

    **Equivalences** (for Fr√©chet spaces):
    - Every CLM to a Banach space is nuclear (Grothendieck-Pietsch)
    - œÄ-tensor product = Œµ-tensor product
    - Every continuous linear map factors through trace-class operators

    **Note**: This definition is not the most general characterization of nuclear spaces
    (which uses trace-class maps between arbitrary local Banach spaces). It is adapted
    to Schwartz/Fr√©chet spaces where a countable Hilbertian basis is available, which
    suffices for the GFF construction.

    **Reference:** Tr√®ves, "Topological Vector Spaces", Ch. 50, Thm 50.1;
    Gel'fand-Vilenkin Vol. 4, Ch. 3-4; Reed-Simon Vol. 1, ¬ßV.3. -/
class NuclearSpace (E : Type*) [AddCommGroup E] [Module ‚Ñù E] [TopologicalSpace E] : Prop where
  nuclear_hilbert_embeddings :
    ‚àÉ (p : ‚Ñï ‚Üí Seminorm ‚Ñù E),
      (‚àÄ n, (p n).IsHilbertian) ‚àß
      (WithSeminorms (fun n => p n)) ‚àß
      (‚àÄ n, ‚àÉ m, n < m ‚àß (p m).IsHilbertSchmidtEmbedding (p n))

/-! ### Schwartz Space is Nuclear -/

/-- **Schwartz space is nuclear**: For any finite-dimensional real normed space E
    and any real normed space F, the Schwartz space ùì¢(E, F) is a nuclear space.

    **Proof sketch** (Gel'fand-Vilenkin Vol. 4, Thm 3 in Ch. 4; Tr√®ves Ch. 51):
    The Hermite functions {h‚Çô} form an ONB for L¬≤(‚Ñù·µà) and are eigenfunctions of the
    harmonic oscillator H = -Œî + |x|¬≤. The Sobolev-Hermite norms
      ‚Äñf‚Äñ_k¬≤ = ‚àë‚Çô (1+n)^{2k} |‚ü®f, h‚Çô‚ü©|¬≤
    are Hilbertian and generate the Schwartz topology. The inclusion from level k+1
    to level k has eigenvalues (1+n)^{-1}, and ‚àë‚Çô (1+n)^{-2} = œÄ¬≤/6 < ‚àû,
    so each inclusion is Hilbert-Schmidt. -/
-- (historical placeholder; removed from Lean code) schwartz_nuclear {E F : Type*}
    [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [FiniteDimensional ‚Ñù E]
    [NormedAddCommGroup F] [NormedSpace ‚Ñù F] :
    NuclearSpace (SchwartzMap E F)

end
### Answer
Based on my analysis of the mathlib4 codebase, here is a comprehensive assessment of the available and missing API for proving `schwartz_nuclear` as a theorem:

## Available API and Prerequisites

### 1. **Schwartz Space Infrastructure** ‚úì
The basic structure of Schwartz spaces with seminorms is well-developed:
- Schwartz space definition with decay conditions mathlib4:82-88 
- Seminorm family for Schwartz space mathlib4:407-410 
- Topology via seminorms mathlib4:504-505 
- Locally convex structure mathlib4:528-529 

### 2. **Seminorm Theory and WithSeminorms** ‚úì
The infrastructure for topologies defined by seminorm families exists:
- `WithSeminorms` predicate mathlib4:25-27 
- Module filter basis from seminorms mathlib4:179-184 
- Verification that Schwartz space satisfies `WithSeminorms` mathlib4:507-511 

### 3. **Parallelogram Law and Inner Product Recovery** ‚úì
The theory for recovering inner products from norms is complete:
- Parallelogram identity predicate mathlib4:70-72 
- Polarization identity construction mathlib4:91-94 
- Fr√©chet-von Neumann-Jordan theorem mathlib4:206-214 

### 4. **Hilbert Space and L¬≤ Theory** ‚úì
Complete Hilbert space infrastructure exists:
- L¬≤ space as inner product space mathlib4:1-100 
- Completeness of Lp spaces mathlib4:1-50 
- Hilbert basis structure mathlib4:40-52 
- Orthonormal families mathlib4:1-100 

### 5. **Hermite Polynomials** ‚úì (Partial)
Basic Hermite polynomial theory exists:
- Hermite polynomial definition mathlib4:1-50 
- Connection to Gaussian derivatives mathlib4:42-59 

### 6. **Summability Theory** ‚úì
Required summability results exist:
- Norm-bounded summability mathlib4:1-100 
- p-series convergence (needed for ‚àë n^{-2s}) mathlib4:1-50 

### 7. **Compact Operators** ‚úì (Partial)
Basic compact operator theory exists:
- `IsCompactOperator` predicate mathlib4:63-65 
- Characterizations of compact operators mathlib4:78-88 

## Missing API (Critical Gaps)

### 1. **Hermite Functions as Orthonormal Basis** ‚úó
**Missing:** The construction of Hermite functions œà‚Çô(x) = hermite(n, x) ¬∑ exp(-x¬≤/2) as an orthonormal basis for L¬≤(‚Ñù).
- Need: Normalization constants
- Need: Proof of orthonormality in L¬≤
- Need: Proof of completeness (dense span in L¬≤)

### 2. **Harmonic Oscillator Spectral Theory** ‚úó
**Missing:** The operator H = -Œî + |x|¬≤ and its spectral properties.
- Need: Definition of H as self-adjoint operator
- Need: Proof that Hermite functions are eigenfunctions
- Need: Eigenvalues Œª‚Çô = 2n + d for ‚Ñù·µà

### 3. **Sobolev-Hermite Seminorms** ‚úó
**Missing:** The Hermite expansion-based seminorms ‚Äñf‚Äñ‚Çñ¬≤ = ‚àë‚Çô (1+n)^{2k} |‚ü®f, h‚Çô‚ü©|¬≤.
- Need: Definition via Hermite coefficients
- Need: Proof these are seminorms
- Need: Proof they are Hilbertian (satisfy parallelogram law)
- Need: Equivalence to standard Schwartz seminorms

### 4. **Hilbert-Schmidt Operator Theory** ‚úó
**Missing:** Complete theory of Hilbert-Schmidt operators.
- Need: Definition of HS operators between Hilbert spaces
- Need: HS norm: ‚ÄñT‚Äñ¬≤‚Çï‚Çõ = ‚àë·µ¢ ‚ÄñT e·µ¢‚Äñ¬≤ for ONB {e·µ¢}
- Need: Independence of HS norm from choice of ONB
- Need: Composition theorems: HS ‚àò bounded = HS, bounded ‚àò HS = HS

### 5. **Nuclear (Trace-Class) Operator Theory** ‚úó
**Missing:** Theory of nuclear operators beyond the definition in the axiom file.
- Need: Trace-class operators on Hilbert spaces
- Need: Nuclear norm: ‚ÄñT‚Äñ‚ÇÅ = tr(‚àö(T*T))
- Need: Key theorem: HS ‚àò HS = trace-class
- Need: Approximation by finite-rank operators

### 6. **Topology Equivalence** ‚úó
**Missing:** Proof that Sobolev-Hermite seminorms generate the same topology as standard Schwartz seminorms.
- Need: Two-sided bounds relating the seminorm families
- Current Schwartz seminorms: mathlib4:210-211 

### 7. **Hilbert-Schmidt Characterization for Diagonal Operators** ‚úó
**Missing:** For diagonal operators with eigenvalues {œÉ‚Çô}, the condition ‚àë œÉ‚Çô¬≤ < ‚àû characterizes Hilbert-Schmidt.
- Need: Diagonal operator theory
- Need: Relationship between eigenvalues and HS norm

### 8. **Fr√©chet Space Theory** ‚úó (Partial)
**Missing:** Additional Fr√©chet space infrastructure:
- Need: Characterization of Fr√©chet spaces via countable seminorms
- Need: Bounded operators between Fr√©chet spaces
- Partial: Locally convex theory exists but incomplete for Fr√©chet case

## Proof Strategy Outline

To prove `schwartz_nuclear`, you would need to:

1. **Construct Hermite basis for L¬≤(‚Ñù·µà)** using the polynomial results and Gaussian functions
2. **Define Sobolev-Hermite seminorms** using Hermite coefficients  
3. **Prove these seminorms are Hilbertian** by verifying the parallelogram law
4. **Show topology equivalence** between Hermite seminorms and standard Schwartz seminorms
5. **Verify Hilbert-Schmidt condition**: For inclusion from level k+1 to level k, compute:
   - For p-orthonormal sequence {e·µ¢} at level k+1
   - Show ‚àë·µ¢ ‚Äñe·µ¢‚Äñ¬≤‚Çñ is bounded
   - Use eigenvalue decay: (1+n)^{-2} summability (œÄ¬≤/6)
6. **Apply definition** of `NuclearSpace` with the constructed seminorm family

## Notes

The main structural gap is in **functional analysis infrastructure** rather than topology or Schwartz space theory. The Schwartz space itself is well-formalized, but the operator-theoretic tools (Hilbert-Schmidt, nuclear operators) and spectral theory (harmonic oscillator) needed for this characterization are missing.

The proof requires substantial development in:
- **Special function theory** (Hermite functions)
- **Spectral theory** (unbounded self-adjoint operators)  
- **Operator ideals** (Hilbert-Schmidt and trace-class operators)

These are major projects that would significantly expand mathlib4's functional analysis capabilities.
### Citations
**File:** Mathlib/Analysis/Distribution/SchwartzSpace.lean (L82-88)
```text
structure SchwartzMap where
  /-- The underlying function.

  Do NOT use directly. Use the coercion instead. -/
  toFun : E ‚Üí F
  smooth' : ContDiff ‚Ñù ‚àû toFun
  decay' : ‚àÄ k n : ‚Ñï, ‚àÉ C : ‚Ñù, ‚àÄ x, ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n toFun x‚Äñ ‚â§ C
```
**File:** Mathlib/Analysis/Distribution/SchwartzSpace.lean (L210-211)
```text
protected def seminormAux (k n : ‚Ñï) (f : ùì¢(E, F)) : ‚Ñù :=
  sInf { c | 0 ‚â§ c ‚àß ‚àÄ x, ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n f x‚Äñ ‚â§ c }
```
**File:** Mathlib/Analysis/Distribution/SchwartzSpace.lean (L407-410)
```text
`ùì¢(E, F)`. -/
protected def seminorm (k n : ‚Ñï) : Seminorm ùïú ùì¢(E, F) :=
  Seminorm.ofSMulLE (SchwartzMap.seminormAux k n) (seminormAux_zero k n) (seminormAux_add_le k n)
    (seminormAux_smul_le k n)
```
**File:** Mathlib/Analysis/Distribution/SchwartzSpace.lean (L504-505)
```text
instance instTopologicalSpace : TopologicalSpace ùì¢(E, F) :=
  (schwartzSeminormFamily ‚Ñù E F).moduleFilterBasis.topology'
```
**File:** Mathlib/Analysis/Distribution/SchwartzSpace.lean (L507-511)
```text
theorem _root_.schwartz_withSeminorms : WithSeminorms (schwartzSeminormFamily ùïú E F) := by
  have A : WithSeminorms (schwartzSeminormFamily ‚Ñù E F) := ‚ü®rfl‚ü©
  rw [SeminormFamily.withSeminorms_iff_nhds_eq_iInf] at A ‚ä¢
  rw [A]
  rfl
```
**File:** Mathlib/Analysis/Distribution/SchwartzSpace.lean (L528-529)
```text
instance instLocallyConvexSpace : LocallyConvexSpace ‚Ñù ùì¢(E, F) :=
  (schwartz_withSeminorms ‚Ñù E F).toLocallyConvexSpace
```
**File:** Mathlib/Analysis/LocallyConvex/WithSeminorms.lean (L25-27)
```text
* `WithSeminorms p`, when `p` is a family of seminorms on `E`, is a proposition expressing that the
  (existing) topology on `E` is induced by the seminorms `p`.
* `PolynormableSpace ùïú E` is a class asserting that the (existing) topology on `E` is induced
```
**File:** Mathlib/Analysis/LocallyConvex/WithSeminorms.lean (L179-184)
```text
/-- The `moduleFilterBasis` induced by the filter basis `Seminorm.basisSets`. -/
protected def moduleFilterBasis : ModuleFilterBasis ùïú F where
  toAddGroupFilterBasis := p.addGroupFilterBasis
  smul' := p.basisSets_smul _
  smul_left' := p.basisSets_smul_left
  smul_right' := p.basisSets_smul_right
```
**File:** Mathlib/Analysis/InnerProductSpace/OfNorm.lean (L70-72)
```text
class InnerProductSpaceable : Prop where
  parallelogram_identity :
    ‚àÄ x y : E, ‚Äñx + y‚Äñ * ‚Äñx + y‚Äñ + ‚Äñx - y‚Äñ * ‚Äñx - y‚Äñ = 2 * (‚Äñx‚Äñ * ‚Äñx‚Äñ + ‚Äñy‚Äñ * ‚Äñy‚Äñ)
```
**File:** Mathlib/Analysis/InnerProductSpace/OfNorm.lean (L91-94)
```text
private noncomputable def inner_ (x y : E) : ùïú :=
  4‚Åª¬π * (ùìö ‚Äñx + y‚Äñ * ùìö ‚Äñx + y‚Äñ - ùìö ‚Äñx - y‚Äñ * ùìö ‚Äñx - y‚Äñ +
    (I : ùïú) * ùìö ‚Äñ(I : ùïú) ‚Ä¢ x + y‚Äñ * ùìö ‚Äñ(I : ùïú) ‚Ä¢ x + y‚Äñ -
    (I : ùïú) * ùìö ‚Äñ(I : ùïú) ‚Ä¢ x - y‚Äñ * ùìö ‚Äñ(I : ùïú) ‚Ä¢ x - y‚Äñ)
```
**File:** Mathlib/Analysis/InnerProductSpace/OfNorm.lean (L206-214)
```text
noncomputable def InnerProductSpace.ofNorm
    (h : ‚àÄ x y : E, ‚Äñx + y‚Äñ * ‚Äñx + y‚Äñ + ‚Äñx - y‚Äñ * ‚Äñx - y‚Äñ = 2 * (‚Äñx‚Äñ * ‚Äñx‚Äñ + ‚Äñy‚Äñ * ‚Äñy‚Äñ)) :
    InnerProductSpace ùïú E :=
  haveI : InnerProductSpaceable E := ‚ü®h‚ü©
  { inner := inner_ ùïú
    norm_sq_eq_re_inner := inner_.norm_sq
    conj_inner_symm := inner_.conj_symm
    add_left := InnerProductSpaceable.add_left
    smul_left := fun _ _ _ => innerProp _ _ _ }
```
**File:** Mathlib/MeasureTheory/Function/L2Space.lean (L1-100)
```text
/-
Copyright (c) 2021 R√©my Degenne. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: R√©my Degenne
-/
module

public import Mathlib.Analysis.InnerProductSpace.LinearMap
public import Mathlib.Analysis.RCLike.Lemmas
public import Mathlib.MeasureTheory.Function.LpSpace.ContinuousFunctions
public import Mathlib.MeasureTheory.Function.StronglyMeasurable.Inner
public import Mathlib.MeasureTheory.Integral.Bochner.ContinuousLinearMap

/-! # `L^2` space

If `E` is an inner product space over `ùïú` (`‚Ñù` or `‚ÑÇ`), then `Lp E 2 Œº`
(defined in `Mathlib/MeasureTheory/Function/LpSpace/Basic.lean`)
is also an inner product space, with inner product defined as `inner f g := ‚à´ a, ‚ü™f a, g a‚ü´ ‚àÇŒº`.

### Main results

* `mem_L1_inner` : for `f` and `g` in `Lp E 2 Œº`, the pointwise inner product `fun x ‚Ü¶ ‚ü™f x, g x‚ü´`
  belongs to `Lp ùïú 1 Œº`.
* `integrable_inner` : for `f` and `g` in `Lp E 2 Œº`, the pointwise inner product
  `fun x ‚Ü¶ ‚ü™f x, g x‚ü´` is integrable.
* `L2.innerProductSpace` : `Lp E 2 Œº` is an inner product space.
-/

@[expose] public section

noncomputable section

open TopologicalSpace MeasureTheory MeasureTheory.Lp Filter

open scoped NNReal ENNReal MeasureTheory InnerProductSpace

namespace MeasureTheory

section

variable {Œ± F : Type*} {m : MeasurableSpace Œ±} {Œº : Measure Œ±} [NormedAddCommGroup F]

theorem MemLp.integrable_sq {f : Œ± ‚Üí ‚Ñù} (h : MemLp f 2 Œº) : Integrable (fun x => f x ^ 2) Œº := by
  simpa [‚Üê memLp_one_iff_integrable] using h.norm_rpow two_ne_zero ENNReal.ofNat_ne_top

theorem memLp_two_iff_integrable_sq_norm {f : Œ± ‚Üí F} (hf : AEStronglyMeasurable f Œº) :
    MemLp f 2 Œº ‚Üî Integrable (fun x => ‚Äñf x‚Äñ ^ 2) Œº := by
  rw [‚Üê memLp_one_iff_integrable]
  convert (memLp_norm_rpow_iff hf two_ne_zero ENNReal.ofNat_ne_top).symm
  ¬∑ simp
  ¬∑ rw [div_eq_mul_inv, ENNReal.mul_inv_cancel two_ne_zero ENNReal.ofNat_ne_top]

theorem memLp_two_iff_integrable_sq {f : Œ± ‚Üí ‚Ñù} (hf : AEStronglyMeasurable f Œº) :
    MemLp f 2 Œº ‚Üî Integrable (fun x => f x ^ 2) Œº := by
  convert memLp_two_iff_integrable_sq_norm hf using 3
  simp

end

section InnerProductSpace

variable {Œ± : Type*} {m : MeasurableSpace Œ±} {p : ‚Ñù‚â•0‚àû} {Œº : Measure Œ±}
variable {E ùïú : Type*} [RCLike ùïú] [NormedAddCommGroup E] [InnerProductSpace ùïú E]

local notation "‚ü™" x ", " y "‚ü´" => inner ùïú x y

theorem MemLp.const_inner (c : E) {f : Œ± ‚Üí E} (hf : MemLp f p Œº) : MemLp (fun a => ‚ü™c, f a‚ü´) p Œº :=
  hf.of_le_mul (AEStronglyMeasurable.inner aestronglyMeasurable_const hf.1)
    (Eventually.of_forall fun _ => norm_inner_le_norm _ _)

theorem MemLp.inner_const {f : Œ± ‚Üí E} (hf : MemLp f p Œº) (c : E) : MemLp (fun a => ‚ü™f a, c‚ü´) p Œº :=
  hf.of_le_mul (c := ‚Äñc‚Äñ) (AEStronglyMeasurable.inner hf.1 aestronglyMeasurable_const)
    (Eventually.of_forall fun x => by rw [mul_comm]; exact norm_inner_le_norm _ _)

variable {f : Œ± ‚Üí E}

@[fun_prop]
theorem Integrable.const_inner (c : E) (hf : Integrable f Œº) :
    Integrable (fun x => ‚ü™c, f x‚ü´) Œº := by
  rw [‚Üê memLp_one_iff_integrable] at hf ‚ä¢; exact hf.const_inner c

@[fun_prop]
theorem Integrable.inner_const (hf : Integrable f Œº) (c : E) :
    Integrable (fun x => ‚ü™f x, c‚ü´) Œº := by
  rw [‚Üê memLp_one_iff_integrable] at hf ‚ä¢; exact hf.inner_const c

variable [CompleteSpace E] [NormedSpace ‚Ñù E]

theorem _root_.integral_inner {f : Œ± ‚Üí E} (hf : Integrable f Œº) (c : E) :
    ‚à´ x, ‚ü™c, f x‚ü´ ‚àÇŒº = ‚ü™c, ‚à´ x, f x ‚àÇŒº‚ü´ :=
  ((innerSL ùïú c).restrictScalars ‚Ñù).integral_comp_comm hf

variable (ùïú)

theorem _root_.integral_eq_zero_of_forall_integral_inner_eq_zero (f : Œ± ‚Üí E) (hf : Integrable f Œº)
    (hf_int : ‚àÄ c : E, ‚à´ x, ‚ü™c, f x‚ü´ ‚àÇŒº = 0) : ‚à´ x, f x ‚àÇŒº = 0 := by
  specialize hf_int (‚à´ x, f x ‚àÇŒº); rwa [integral_inner hf, inner_self_eq_zero] at hf_int

end InnerProductSpace

```
**File:** Mathlib/MeasureTheory/Function/LpSpace/Complete.lean (L1-50)
```text
/-
Copyright (c) 2020 R√©my Degenne. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: R√©my Degenne, S√©bastien Gou√´zel
-/
module

public import Mathlib.Analysis.SpecialFunctions.Pow.Continuity
public import Mathlib.MeasureTheory.Function.LpSpace.Basic

/-!
# `Lp` is a complete space

In this file we show that `Lp` is a complete space for `1 ‚â§ p`,
in `MeasureTheory.Lp.instCompleteSpace`.
-/

@[expose] public section

open MeasureTheory Filter
open scoped ENNReal Topology

variable {Œ± E : Type*} {m : MeasurableSpace Œ±} {p : ‚Ñù‚â•0‚àû} {Œº : Measure Œ±} [SeminormedAddGroup E]

namespace MeasureTheory.Lp

theorem eLpNorm'_lim_eq_lintegral_liminf {Œπ} [Nonempty Œπ] [LinearOrder Œπ] {f : Œπ ‚Üí Œ± ‚Üí E} {p : ‚Ñù}
    {f_lim : Œ± ‚Üí E} (h_lim : ‚àÄ·µê x : Œ± ‚àÇŒº, Tendsto (fun n => f n x) atTop (ùìù (f_lim x))) :
    eLpNorm' f_lim p Œº = (‚à´‚Åª a, atTop.liminf (‚Äñf ¬∑ a‚Äñ‚Çë ^ p) ‚àÇŒº) ^ (1 / p) := by
  suffices h_no_pow : (‚à´‚Åª a, ‚Äñf_lim a‚Äñ‚Çë ^ p ‚àÇŒº) = ‚à´‚Åª a, atTop.liminf fun m => ‚Äñf m a‚Äñ‚Çë ^ p ‚àÇŒº by
    rw [eLpNorm'_eq_lintegral_enorm, h_no_pow]
  refine lintegral_congr_ae (h_lim.mono fun a ha => ?_)
  dsimp only
  rw [Tendsto.liminf_eq]
  refine (ENNReal.continuous_rpow_const.tendsto ‚Äñf_lim a‚Äñ‚Çä).comp ?_
  exact (continuous_enorm.tendsto (f_lim a)).comp ha

theorem eLpNorm'_lim_le_liminf_eLpNorm' {f : ‚Ñï ‚Üí Œ± ‚Üí E} {p : ‚Ñù}
    (hp_pos : 0 < p) (hf : ‚àÄ n, AEStronglyMeasurable (f n) Œº) {f_lim : Œ± ‚Üí E}
    (h_lim : ‚àÄ·µê x : Œ± ‚àÇŒº, Tendsto (fun n => f n x) atTop (ùìù (f_lim x))) :
    eLpNorm' f_lim p Œº ‚â§ atTop.liminf fun n => eLpNorm' (f n) p Œº := by
  rw [eLpNorm'_lim_eq_lintegral_liminf h_lim]
  rw [one_div, ‚Üê ENNReal.le_rpow_inv_iff (by simp [hp_pos] : 0 < p‚Åª¬π), inv_inv]
  refine (lintegral_liminf_le' fun m => (hf m).enorm.pow_const _).trans_eq ?_
  have h_pow_liminf :
    atTop.liminf (fun n ‚Ü¶ eLpNorm' (f n) p Œº) ^ p
      = atTop.liminf fun n ‚Ü¶ eLpNorm' (f n) p Œº ^ p := by
    have h_rpow_mono := ENNReal.strictMono_rpow_of_pos hp_pos
    have h_rpow_surj := (ENNReal.rpow_left_bijective hp_pos.ne.symm).2
    refine (h_rpow_mono.orderIsoOfSurjective _ h_rpow_surj).liminf_apply ?_ ?_ ?_ ?_
```
**File:** Mathlib/Analysis/InnerProductSpace/l2Space.lean (L40-52)
```text
* `HilbertBasis`: We define a *Hilbert basis* of a Hilbert space `E` to be a structure whose single
  field `HilbertBasis.repr` is an isometric isomorphism of `E` with `‚Ñì¬≤(Œπ, ùïú)` (i.e., the Hilbert
  sum of `Œπ` copies of `ùïú`).  This parallels the definition of `Basis`, in `LinearAlgebra.Basis`,
  as an isomorphism of an `R`-module with `Œπ ‚Üí‚ÇÄ R`.

* `HilbertBasis.instCoeFun`: More conventionally a Hilbert basis is thought of as a family
  `Œπ ‚Üí E` of vectors in `E` satisfying certain properties (orthonormality, completeness).  We obtain
  this interpretation of a Hilbert basis `b` by defining `‚áëb`, of type `Œπ ‚Üí E`, to be the image
  under `b.repr` of `lp.single 2 i (1:ùïú)`.  This parallels the definition `Basis.coeFun` in
  `LinearAlgebra.Basis`.

* `HilbertBasis.mk`: Make a Hilbert basis of `E` from an orthonormal family `v : Œπ ‚Üí E` of vectors
  in `E` whose span is dense.  This parallels the definition `Basis.mk` in `LinearAlgebra.Basis`.
```
**File:** Mathlib/Analysis/InnerProductSpace/Orthonormal.lean (L1-100)
```text
/-
Copyright (c) 2019 Zhouhang Zhou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Zhouhang Zhou, S√©bastien Gou√´zel, Fr√©d√©ric Dupuis
-/
module

public import Mathlib.Analysis.InnerProductSpace.LinearMap
public import Mathlib.LinearAlgebra.FiniteDimensional.Lemmas
public import Mathlib.RingTheory.LocalRing.Basic

/-!
# Orthonormal sets

This file defines orthonormal sets in inner product spaces.

## Main results

- We define `Orthonormal`, a predicate on a function `v : Œπ ‚Üí E`, and prove the existence of a
  maximal orthonormal set, `exists_maximal_orthonormal`.
- Bessel's inequality, `Orthonormal.tsum_inner_products_le`, states that given an orthonormal set
  `v` and a vector `x`, the sum of the norm-squares of the inner products `‚ü™v i, x‚ü´` is no more
  than the norm-square of `x`.

For the existence of orthonormal bases, Hilbert bases, etc., see the file
`Analysis.InnerProductSpace.projection`.
-/

@[expose] public section

noncomputable section

open RCLike Real Filter Module Topology ComplexConjugate Finsupp

open LinearMap (BilinForm)

variable {ùïú E F : Type*} [RCLike ùïú]

section OrthonormalSets_Seminormed

variable [SeminormedAddCommGroup E] [InnerProductSpace ùïú E]
variable [SeminormedAddCommGroup F] [InnerProductSpace ‚Ñù F]

local notation "‚ü™" x ", " y "‚ü´" => inner ùïú x y

variable {Œπ : Type*} (ùïú)

/-- An orthonormal set of vectors in an `InnerProductSpace` -/
def Orthonormal (v : Œπ ‚Üí E) : Prop :=
  (‚àÄ i, ‚Äñv i‚Äñ = 1) ‚àß Pairwise fun i j => ‚ü™v i, v j‚ü´ = 0

variable {ùïú}

@[simp]
lemma Orthonormal.of_isEmpty [IsEmpty Œπ] (v : Œπ ‚Üí E) : Orthonormal ùïú v :=
  ‚ü®IsEmpty.elim ‚Äπ_‚Ä∫, Subsingleton.pairwise‚ü©

@[simp]
lemma orthonormal_vecCons_iff {n : ‚Ñï} {v : E} {vs : Fin n ‚Üí E} :
    Orthonormal ùïú (Matrix.vecCons v vs) ‚Üî ‚Äñv‚Äñ = 1 ‚àß (‚àÄ i, ‚ü™v, vs i‚ü´ = 0) ‚àß Orthonormal ùïú vs := by
  simp_rw [Orthonormal, pairwise_fin_succ_iff_of_isSymm, Fin.forall_fin_succ]
  tauto

lemma Orthonormal.norm_eq_one {v : Œπ ‚Üí E} (h : Orthonormal ùïú v) (i : Œπ) :
    ‚Äñv i‚Äñ = 1 := h.1 i

lemma Orthonormal.nnnorm_eq_one {v : Œπ ‚Üí E} (h : Orthonormal ùïú v) (i : Œπ) :
    ‚Äñv i‚Äñ‚Çä = 1 := by
  suffices (‚Äñv i‚Äñ‚Çä : ‚Ñù) = 1 by norm_cast at this
  simp [h.norm_eq_one]

lemma Orthonormal.enorm_eq_one {v : Œπ ‚Üí E} (h : Orthonormal ùïú v) (i : Œπ) :
    ‚Äñv i‚Äñ‚Çë = 1 := by rw [‚Üê ofReal_norm]; simp [h.norm_eq_one]

lemma Orthonormal.inner_eq_zero {v : Œπ ‚Üí E} {i j : Œπ} (h : Orthonormal ùïú v) (hij : i ‚â† j) :
    ‚ü™v i, v j‚ü´ = 0 := h.2 hij

/-- `if ... then ... else` characterization of an indexed set of vectors being orthonormal.  (Inner
product equals Kronecker delta.) -/
theorem orthonormal_iff_ite [DecidableEq Œπ] {v : Œπ ‚Üí E} :
    Orthonormal ùïú v ‚Üî ‚àÄ i j, ‚ü™v i, v j‚ü´ = if i = j then (1 : ùïú) else (0 : ùïú) := by
  constructor
  ¬∑ intro hv i j
    split_ifs with h
    ¬∑ simp [h, inner_self_eq_norm_sq_to_K, hv.norm_eq_one]
    ¬∑ exact hv.inner_eq_zero h
  ¬∑ intro h
    constructor
    ¬∑ intro i
      have h' : ‚Äñv i‚Äñ ^ 2 = 1 ^ 2 := by
        rw [@norm_sq_eq_re_inner ùïú, h i i]; simp
      have h‚ÇÅ : 0 ‚â§ ‚Äñv i‚Äñ := norm_nonneg _
      have h‚ÇÇ : (0 : ‚Ñù) ‚â§ 1 := zero_le_one
      rwa [sq_eq_sq‚ÇÄ h‚ÇÅ h‚ÇÇ] at h'
    ¬∑ intro i j hij
      simpa [hij] using h i j

/-- `if ... then ... else` characterization of a set of vectors being orthonormal.  (Inner product
equals Kronecker delta.) -/
theorem orthonormal_subtype_iff_ite [DecidableEq E] {s : Set E} :
```
**File:** Mathlib/RingTheory/Polynomial/Hermite/Basic.lean (L1-50)
```text
/-
Copyright (c) 2023 Luke Mantle. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Luke Mantle
-/
module

public import Mathlib.Algebra.Polynomial.Derivative
public import Mathlib.Data.Nat.Factorial.DoubleFactorial

/-!
# Hermite polynomials

This file defines `Polynomial.hermite n`, the `n`th probabilists' Hermite polynomial.

## Main definitions

* `Polynomial.hermite n`: the `n`th probabilists' Hermite polynomial,
  defined recursively as a `Polynomial ‚Ñ§`

## Results

* `Polynomial.hermite_succ`: the recursion `hermite (n+1) = (x - d/dx) (hermite n)`
* `Polynomial.coeff_hermite_explicit`: a closed formula for (nonvanishing) coefficients in terms
  of binomial coefficients and double factorials.
* `Polynomial.coeff_hermite_of_odd_add`: for `n`,`k` where `n+k` is odd, `(hermite n).coeff k` is
  zero.
* `Polynomial.coeff_hermite_of_even_add`: a closed formula for `(hermite n).coeff k` when `n+k` is
  even, equivalent to `Polynomial.coeff_hermite_explicit`.
* `Polynomial.monic_hermite`: for all `n`, `hermite n` is monic.
* `Polynomial.degree_hermite`: for all `n`, `hermite n` has degree `n`.

## References

* [Hermite Polynomials](https://en.wikipedia.org/wiki/Hermite_polynomials)

-/

@[expose] public section

noncomputable section

open Polynomial

namespace Polynomial

/-- the probabilists' Hermite polynomials. -/
noncomputable def hermite : ‚Ñï ‚Üí Polynomial ‚Ñ§
  | 0 => 1
  | n + 1 => X * hermite n - derivative (hermite n)
```
**File:** Mathlib/RingTheory/Polynomial/Hermite/Gaussian.lean (L42-59)
```text
theorem deriv_gaussian_eq_hermite_mul_gaussian (n : ‚Ñï) (x : ‚Ñù) :
    deriv^[n] (fun y => Real.exp (-(y ^ 2 / 2))) x =
    (-1 : ‚Ñù) ^ n * aeval x (hermite n) * Real.exp (-(x ^ 2 / 2)) := by
  rw [mul_assoc]
  induction n generalizing x with
  | zero => rw [Function.iterate_zero_apply, pow_zero, one_mul, hermite_zero, C_1, map_one, one_mul]
  | succ n ih =>
    replace ih : deriv^[n] _ = _ := _root_.funext ih
    have deriv_gaussian :
      deriv (fun y => Real.exp (-(y ^ 2 / 2))) x = -x * Real.exp (-(x ^ 2 / 2)) := by
      -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10745): was `simp [mul_comm, ‚Üê neg_mul]`
      rw [deriv_exp (by simp)]
      simp [mul_comm]
    rw [Function.iterate_succ_apply', ih, deriv_const_mul_field, deriv_fun_mul, pow_succ (-1 : ‚Ñù),
      deriv_gaussian, hermite_succ, map_sub, map_mul, aeval_X, Polynomial.deriv_aeval]
    ¬∑ ring
    ¬∑ apply Polynomial.differentiable_aeval
    ¬∑ apply DifferentiableAt.exp; simp -- Porting note: was just `simp`
```
**File:** Mathlib/Analysis/Normed/Group/InfiniteSum.lean (L1-100)
```text
/-
Copyright (c) 2021 S√©bastien Gou√´zel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: S√©bastien Gou√´zel, Heather Macbeth, Johannes H√∂lzl, Yury Kudryashov
-/
module

public import Mathlib.Algebra.BigOperators.Intervals
public import Mathlib.Analysis.Normed.Group.Uniform
public import Mathlib.Topology.Instances.NNReal.Lemmas
public import Mathlib.Topology.Instances.ENNReal.Lemmas

/-!
# Infinite sums in (semi)normed groups

In a complete (semi)normed group,

- `summable_iff_vanishing_norm`: a series `‚àë' i, f i` is summable if and only if for any `Œµ > 0`,
  there exists a finite set `s` such that the sum `‚àë i ‚àà t, f i` over any finite set `t` disjoint
  with `s` has norm less than `Œµ`;

- `Summable.of_norm_bounded`, `Summable.of_norm_bounded_eventually`: if `‚Äñf i‚Äñ` is bounded above by
  a summable series `‚àë' i, g i`, then `‚àë' i, f i` is summable as well; the same is true if the
  inequality hold only off some finite set.

- `tsum_of_norm_bounded`, `HasSum.norm_le_of_bounded`: if `‚Äñf i‚Äñ ‚â§ g i`, where `‚àë' i, g i` is a
  summable series, then `‚Äñ‚àë' i, f i‚Äñ ‚â§ ‚àë' i, g i`.

- versions of these lemmas for `nnnorm` and `enorm`.

## Tags

infinite series, absolute convergence, normed group
-/

public section

open Topology ENNReal NNReal

open Finset Filter Metric

variable {Œπ Œ± E F Œµ : Type*} [SeminormedAddCommGroup E] [SeminormedAddCommGroup F]
  [TopologicalSpace Œµ] [ESeminormedAddCommMonoid Œµ]

theorem cauchySeq_finset_iff_vanishing_norm {f : Œπ ‚Üí E} :
    (CauchySeq fun s : Finset Œπ => ‚àë i ‚àà s, f i) ‚Üî
      ‚àÄ Œµ > (0 : ‚Ñù), ‚àÉ s : Finset Œπ, ‚àÄ t, Disjoint t s ‚Üí ‚Äñ‚àë i ‚àà t, f i‚Äñ < Œµ := by
  rw [cauchySeq_finset_iff_sum_vanishing, nhds_basis_ball.forall_iff]
  ¬∑ simp only [ball_zero_eq, Set.mem_setOf_eq]
  ¬∑ rintro s t hst ‚ü®s', hs'‚ü©
    exact ‚ü®s', fun t' ht' => hst <| hs' _ ht'‚ü©

theorem summable_iff_vanishing_norm [CompleteSpace E] {f : Œπ ‚Üí E} :
    Summable f ‚Üî ‚àÄ Œµ > (0 : ‚Ñù), ‚àÉ s : Finset Œπ, ‚àÄ t, Disjoint t s ‚Üí ‚Äñ‚àë i ‚àà t, f i‚Äñ < Œµ := by
  rw [summable_iff_cauchySeq_finset, cauchySeq_finset_iff_vanishing_norm]

theorem cauchySeq_finset_of_norm_bounded_eventually {f : Œπ ‚Üí E} {g : Œπ ‚Üí ‚Ñù} (hg : Summable g)
    (h : ‚àÄ·∂† i in cofinite, ‚Äñf i‚Äñ ‚â§ g i) : CauchySeq fun s => ‚àë i ‚àà s, f i := by
  refine cauchySeq_finset_iff_vanishing_norm.2 fun Œµ hŒµ => ?_
  rcases summable_iff_vanishing_norm.1 hg Œµ hŒµ with ‚ü®s, hs‚ü©
  classical
  refine ‚ü®s ‚à™ h.toFinset, fun t ht => ?_‚ü©
  have : ‚àÄ i ‚àà t, ‚Äñf i‚Äñ ‚â§ g i := by
    intro i hi
    simp only [disjoint_left, mem_union, not_or, h.mem_toFinset, Set.mem_compl_iff,
      Classical.not_not] at ht
    exact (ht hi).2
  calc
    ‚Äñ‚àë i ‚àà t, f i‚Äñ ‚â§ ‚àë i ‚àà t, g i := norm_sum_le_of_le _ this
    _ ‚â§ ‚Äñ‚àë i ‚àà t, g i‚Äñ := le_abs_self _
    _ < Œµ := hs _ (ht.mono_right le_sup_left)

theorem cauchySeq_finset_of_norm_bounded {f : Œπ ‚Üí E} {g : Œπ ‚Üí ‚Ñù} (hg : Summable g)
    (h : ‚àÄ i, ‚Äñf i‚Äñ ‚â§ g i) : CauchySeq fun s : Finset Œπ => ‚àë i ‚àà s, f i :=
  cauchySeq_finset_of_norm_bounded_eventually hg <| Eventually.of_forall h

/-- A version of the **direct comparison test** for conditionally convergent series.
See `cauchySeq_finset_of_norm_bounded` for the same statement about absolutely convergent ones. -/
theorem cauchySeq_range_of_norm_bounded {f : ‚Ñï ‚Üí E} {g : ‚Ñï ‚Üí ‚Ñù}
    (hg : CauchySeq fun n => ‚àë i ‚àà range n, g i) (hf : ‚àÄ i, ‚Äñf i‚Äñ ‚â§ g i) :
    CauchySeq fun n => ‚àë i ‚àà range n, f i := by
  refine Metric.cauchySeq_iff'.2 fun Œµ hŒµ => ?_
  refine (Metric.cauchySeq_iff'.1 hg Œµ hŒµ).imp fun N hg n hn => ?_
  specialize hg n hn
  rw [dist_eq_norm, ‚Üê sum_Ico_eq_sub _ hn] at hg ‚ä¢
  calc
    ‚Äñ‚àë k ‚àà Ico N n, f k‚Äñ ‚â§ ‚àë k ‚àà _, ‚Äñf k‚Äñ := norm_sum_le _ _
    _ ‚â§ ‚àë k ‚àà _, g k := sum_le_sum fun x _ => hf x
    _ ‚â§ ‚Äñ‚àë k ‚àà _, g k‚Äñ := le_abs_self _
    _ < Œµ := hg

theorem cauchySeq_finset_of_summable_norm {f : Œπ ‚Üí E} (hf : Summable fun a => ‚Äñf a‚Äñ) :
    CauchySeq fun s : Finset Œπ => ‚àë a ‚àà s, f a :=
  cauchySeq_finset_of_norm_bounded hf fun _i => le_rfl

/-- If a function `f` is summable in norm, and along some sequence of finsets exhausting the space
its sum is converging to a limit `a`, then this holds along all finsets, i.e., `f` is summable
with sum `a`. -/
theorem hasSum_of_subseq_of_summable {f : Œπ ‚Üí E} (hf : Summable fun a => ‚Äñf a‚Äñ) {s : Œ± ‚Üí Finset Œπ}
    {p : Filter Œ±} [NeBot p] (hs : Tendsto s p atTop) {a : E}
```
**File:** Mathlib/Analysis/PSeries.lean (L1-50)
```text
/-
Copyright (c) 2020 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov
-/
module

public import Mathlib.Analysis.SpecialFunctions.Pow.NNReal
public import Mathlib.Analysis.SpecialFunctions.Pow.Continuity
public import Mathlib.Analysis.SumOverResidueClass

/-!
# Convergence of `p`-series

In this file we prove that the series `‚àë' k in ‚Ñï, 1 / k ^ p` converges if and only if `p > 1`.
The proof is based on the
[Cauchy condensation test](https://en.wikipedia.org/wiki/Cauchy_condensation_test): `‚àë k, f k`
converges if and only if so does `‚àë k, 2 ^ k f (2 ^ k)`. We prove this test in
`NNReal.summable_condensed_iff` and `summable_condensed_iff_of_nonneg`, then use it to prove
`summable_one_div_rpow`. After this transformation, a `p`-series turns into a geometric series.

## Tags

p-series, Cauchy condensation test
-/

@[expose] public section

/-!
### Schl√∂milch's generalization of the Cauchy condensation test

In this section we prove the Schl√∂milch's generalization of the Cauchy condensation test:
for a strictly increasing `u : ‚Ñï ‚Üí ‚Ñï` with ratio of successive differences bounded and an
antitone `f : ‚Ñï ‚Üí ‚Ñù‚â•0` or `f : ‚Ñï ‚Üí ‚Ñù`, `‚àë k, f k` converges if and only if
so does `‚àë k, (u (k + 1) - u k) * f (u k)`. Instead of giving a monolithic proof, we split it
into a series of lemmas with explicit estimates of partial sums of each series in terms of the
partial sums of the other series.
-/

/--
A sequence `u` has the property that its ratio of successive differences is bounded
when there is a positive real number `C` such that, for all n ‚àà ‚Ñï,
(u (n + 2) - u (n + 1)) ‚â§ C * (u (n + 1) - u n)
-/
def SuccDiffBounded (C : ‚Ñï) (u : ‚Ñï ‚Üí ‚Ñï) : Prop :=
  ‚àÄ n : ‚Ñï, u (n + 2) - u (n + 1) ‚â§ C ‚Ä¢ (u (n + 1) - u n)

namespace Finset

variable {M : Type*} [AddCommMonoid M] [PartialOrder M] [IsOrderedAddMonoid M]
```
**File:** Mathlib/Analysis/Normed/Operator/Compact.lean (L63-65)
```text
def IsCompactOperator {M‚ÇÅ M‚ÇÇ : Type*} [Zero M‚ÇÅ] [TopologicalSpace M‚ÇÅ] [TopologicalSpace M‚ÇÇ]
    (f : M‚ÇÅ ‚Üí M‚ÇÇ) : Prop :=
  ‚àÉ K, IsCompact K ‚àß f ‚Åª¬π' K ‚àà (ùìù 0 : Filter M‚ÇÅ)
```
**File:** Mathlib/Analysis/Normed/Operator/Compact.lean (L78-88)
```text
theorem isCompactOperator_iff_exists_mem_nhds_image_subset_compact (f : M‚ÇÅ ‚Üí M‚ÇÇ) :
    IsCompactOperator f ‚Üî ‚àÉ V ‚àà (ùìù 0 : Filter M‚ÇÅ), ‚àÉ K : Set M‚ÇÇ, IsCompact K ‚àß f '' V ‚äÜ K :=
  ‚ü®fun ‚ü®K, hK, hKf‚ü© => ‚ü®f ‚Åª¬π' K, hKf, K, hK, image_preimage_subset _ _‚ü©, fun ‚ü®_, hV, K, hK, hVK‚ü© =>
    ‚ü®K, hK, mem_of_superset hV (image_subset_iff.mp hVK)‚ü©‚ü©

theorem isCompactOperator_iff_exists_mem_nhds_isCompact_closure_image [T2Space M‚ÇÇ] (f : M‚ÇÅ ‚Üí M‚ÇÇ) :
    IsCompactOperator f ‚Üî ‚àÉ V ‚àà (ùìù 0 : Filter M‚ÇÅ), IsCompact (closure <| f '' V) := by
  rw [isCompactOperator_iff_exists_mem_nhds_image_subset_compact]
  exact
    ‚ü®fun ‚ü®V, hV, K, hK, hKV‚ü© => ‚ü®V, hV, hK.closure_of_subset hKV‚ü©,
      fun ‚ü®V, hV, hVc‚ü© => ‚ü®V, hV, closure (f '' V), hVc, subset_closure‚ü©‚ü©
```
## Q2
what about this axiom:

/-
Copyright (c) 2025 Michael R. Douglas, Sarah Hoback, Anna Mei, Ron Nissim. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Michael R. Douglas, Sarah Hoback, Anna Mei, Ron Nissim
-/

import Mathlib.Tactic
import Mathlib.Data.Complex.Basic
import Mathlib.Analysis.Complex.Basic
import Mathlib.Analysis.Analytic.Basic
import Mathlib.Analysis.Analytic.Constructions
import Mathlib.Analysis.Analytic.Linear
import Mathlib.Analysis.SpecialFunctions.Complex.Analytic
import Mathlib.Analysis.Distribution.SchwartzSpace.Deriv
import Mathlib.MeasureTheory.Measure.ProbabilityMeasure
import Mathlib.MeasureTheory.Integral.Bochner.Basic
import Mathlib.MeasureTheory.Function.LpSpace.Basic


import OSforGFF.Basic
import OSforGFF.Schwinger
import OSforGFF.OS_Axioms
import OSforGFF.GFFMconstruct
import OSforGFF.ComplexTestFunction
import Mathlib.MeasureTheory.Measure.Complex
import Mathlib.Analysis.Complex.CauchyIntegral
import Mathlib.Analysis.Complex.HasPrimitives
import Mathlib.Topology.Algebra.Module.Basic

/-!
# OS0 Analyticity Axiom

This file contains the proof that the Gaussian Free Field satisfies the OS0 axiom
(analyticity of the generating functional).

## Main Results

- `gaussianFreeField_satisfies_OS0`: The GFF generating functional is analytic.

## Mathematical Background

For a Gaussian measure with covariance C, the generating functional is:
  Z[f] = exp(-¬Ω‚ü®f, Cf‚ü©)

This is analytic in f because:
1. The bilinear form ‚ü®f, Cf‚ü© is continuous
2. The exponential of an analytic function is analytic
3. Finite sums/linear combinations preserve analyticity
-/

noncomputable section

/-! ## Axioms in this file

This file contains the following axiom:
- (none)
-/

open MeasureTheory Complex BigOperators SchwartzMap
open scoped MeasureTheory ComplexConjugate

namespace QFT

/-! ## Analyticity Theorem

The key mathematical fact is that the exponential of a continuous quadratic form
is analytic.
-/


open MeasureTheory Complex

variable {Œ© : Type*} [MeasurableSpace Œ©] (Œº : Measure Œ©)

/-! ### Multivariate Case

The multivariate case uses the same differentiation-under-the-integral approach.
For functions `f : (Fin n ‚Üí ‚ÑÇ) ‚Üí Œ© ‚Üí ‚ÑÇ` where each fiber is ‚ÑÇ-analytic, we show
the integral is ‚ÑÇ-differentiable everywhere, hence analytic.

The key insight is that `Fin n ‚Üí ‚ÑÇ` is a finite-dimensional ‚ÑÇ-vector space,
so analyticity is equivalent to being everywhere ‚ÑÇ-differentiable. -/

-- (historical placeholder; removed from Lean code) differentiable_analyticAt_finDim
### Answer
# Available API and Theorems in mathlib4

## Goursat's Theorem and Complex Differentiability Implies Analyticity

mathlib4 contains a comprehensive formalization of **Goursat's theorem** (the Cauchy-Goursat theorem) for functions `f : ‚ÑÇ ‚Üí E` where `E` is a complex Banach space: mathlib4:263-278 

The key result that **complex differentiable functions are analytic** is proven via the Cauchy integral formula: mathlib4:625-632 

This establishes the equivalence between complex differentiability and analyticity on open sets: mathlib4:668-678 

## Cauchy-Riemann Equations

The **Cauchy-Riemann equations** characterize complex differentiability in terms of real differentiability: mathlib4:224-240 mathlib4:281-289 

## Finite-Dimensional Complex Spaces

For finite-dimensional spaces over complete fields like ‚ÑÇ, all norms are equivalent and all linear maps are continuous: mathlib4:23-51 

## Analytic Functions on Product Spaces

For handling functions of several variables, mathlib4 provides constructions for analytic functions on product spaces: mathlib4:14-22 

The theory uses `FormalMultilinearSeries` to represent power series in several variables, working abstractly over normed spaces rather than specifically for ‚ÑÇ‚Åø.

# What is Missing

## Hartogs' Theorem

**Hartogs' theorem** (stating that separately holomorphic functions on domains in ‚ÑÇ‚Åø with n‚â•2 are jointly holomorphic) is **not formalized in mathlib4**. It is only tracked as an external formalization: mathlib4:1213-1216 

## Several Complex Variables Theory

mathlib4 currently lacks a dedicated theory of several complex variables distinct from general normed space theory. The following are **missing**:

1. **Hartogs' theorem** - as noted above
2. **Hartogs' extension theorem** - also tracked but not in mathlib4: mathlib4:401-402 

3. **Plurisubharmonic functions** - no formalization found
4. **Pseudoconvex domains** - no formalization found  
5. **Osgood's theorem** - no formalization found
6. **Polydisk theory** - no specific API for polydisks in ‚ÑÇ‚Åø

## Key Missing Infrastructure

While mathlib4 has excellent infrastructure for:
- Single complex variable theory (‚ÑÇ ‚Üí E)
- General normed space theory (E ‚Üí F for normed spaces)
- Finite-dimensional spaces over ‚ÑÇ

It lacks:
- Specific theorems about ‚ÑÇ‚Åø ‚Üí ‚ÑÇ that don't follow from general normed space theory
- Characterizations of holomorphicity beyond the Cauchy-Riemann equations for ‚ÑÇ
- Theory distinguishing ‚ÑÇ‚Åø from general finite-dimensional complex normed spaces
- Results specific to several complex variables that have no analogue in general normed spaces (like Hartogs' phenomena)

## Notes

The current approach in mathlib4 treats functions on ‚ÑÇ‚Åø (represented as product types or `Fin n ‚Üí ‚ÑÇ`) using the general theory of analytic functions between normed spaces. While this provides power series expansions, composition, and arithmetic operations, it doesn't capture the special phenomena of several complex variables theory that distinguish it from real or general normed space analysis.
### Citations
**File:** Mathlib/Analysis/Complex/CauchyIntegral.lean (L263-278)
```text
/-- **Cauchy-Goursat theorem** for a rectangle: the integral of a complex differentiable function
over the boundary of a rectangle equals zero. More precisely, if `f` is continuous on a closed
rectangle and is complex differentiable at all but countably many points of the corresponding open
rectangle, then its integral over the boundary of the rectangle equals zero. -/
theorem integral_boundary_rect_eq_zero_of_differentiable_on_off_countable (f : ‚ÑÇ ‚Üí E) (z w : ‚ÑÇ)
    (s : Set ‚ÑÇ) (hs : s.Countable) (Hc : ContinuousOn f ([[z.re, w.re]] √ó‚ÑÇ [[z.im, w.im]]))
    (Hd : ‚àÄ x ‚àà Ioo (min z.re w.re) (max z.re w.re) √ó‚ÑÇ Ioo (min z.im w.im) (max z.im w.im) \ s,
      DifferentiableAt ‚ÑÇ f x) :
    (‚à´ x : ‚Ñù in z.re..w.re, f (x + z.im * I)) - (‚à´ x : ‚Ñù in z.re..w.re, f (x + w.im * I)) +
      I ‚Ä¢ (‚à´ y : ‚Ñù in z.im..w.im, f (re w + y * I)) -
      I ‚Ä¢ (‚à´ y : ‚Ñù in z.im..w.im, f (re z + y * I)) = 0 := by
  refine (integral_boundary_rect_of_hasFDerivAt_real_off_countable f
    (fun z => (fderiv ‚ÑÇ f z).restrictScalars ‚Ñù) z w s hs Hc
    (fun x hx => (Hd x hx).hasFDerivAt.restrictScalars ‚Ñù) ?_).trans ?_ <;>
      simp

```
**File:** Mathlib/Analysis/Complex/CauchyIntegral.lean (L625-632)
```text
/-- If `f : ‚ÑÇ ‚Üí E` is complex differentiable on some set `s`, then it is analytic at any point `z`
such that `s ‚àà ùìù z` (equivalently, `z ‚àà interior s`). -/
protected theorem _root_.DifferentiableOn.analyticAt {s : Set ‚ÑÇ} {f : ‚ÑÇ ‚Üí E} {z : ‚ÑÇ}
    (hd : DifferentiableOn ‚ÑÇ f s) (hz : s ‚àà ùìù z) : AnalyticAt ‚ÑÇ f z := by
  rcases nhds_basis_closedBall.mem_iff.1 hz with ‚ü®R, hR0, hRs‚ü©
  lift R to ‚Ñù‚â•0 using hR0.le
  exact ((hd.mono hRs).hasFPowerSeriesOnBall hR0).analyticAt

```
**File:** Mathlib/Analysis/Complex/CauchyIntegral.lean (L668-678)
```text
/-- On an open set, `f : ‚ÑÇ ‚Üí E` is analytic iff it is differentiable -/
theorem analyticOnNhd_iff_differentiableOn {f : ‚ÑÇ ‚Üí E} {s : Set ‚ÑÇ} (o : IsOpen s) :
    AnalyticOnNhd ‚ÑÇ f s ‚Üî DifferentiableOn ‚ÑÇ f s :=
  ‚ü®AnalyticOnNhd.differentiableOn, fun d _ zs ‚Ü¶ d.analyticAt (o.mem_nhds zs)‚ü©

/-- On an open set, `f : ‚ÑÇ ‚Üí E` is analytic iff it is differentiable -/
theorem analyticOn_iff_differentiableOn {f : ‚ÑÇ ‚Üí E} {s : Set ‚ÑÇ} (o : IsOpen s) :
    AnalyticOn ‚ÑÇ f s ‚Üî DifferentiableOn ‚ÑÇ f s := by
  rw [o.analyticOn_iff_analyticOnNhd]
  exact analyticOnNhd_iff_differentiableOn o

```
**File:** Mathlib/Analysis/Complex/Conformal.lean (L224-240)
```text
/--
The **Cauchy-Riemann Equation**: A real-differentiable function `f` on `‚ÑÇ` is complex-differentiable
at `x` within `s` iff the derivative `fderivWithin ‚Ñù f s x` maps `I` to
`I ‚Ä¢ (fderivWithin ‚Ñù f s x) 1`.
-/
theorem differentiableWithinAt_complex_iff_differentiableWithinAt_real
    (hs : UniqueDiffWithinAt ‚Ñù s x) :
    DifferentiableWithinAt ‚ÑÇ f s x ‚Üî DifferentiableWithinAt ‚Ñù f s x ‚àß
      (fderivWithin ‚Ñù f s x I = I ‚Ä¢ fderivWithin ‚Ñù f s x 1) := by
  refine ‚ü®fun h ‚Ü¶ ‚ü®h.restrictScalars ‚Ñù, ?_‚ü©, fun ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© ‚Ü¶ ?_‚ü©
  ¬∑ simp only [‚Üê h.restrictScalars_fderivWithin ‚Ñù hs, ContinuousLinearMap.coe_restrictScalars']
    rw [(by simp : I = I ‚Ä¢ 1), (fderivWithin ‚ÑÇ f s x).map_smul]
    simp
  ¬∑ apply (differentiableWithinAt_iff_restrictScalars ‚Ñù h‚ÇÅ hs).2
    use (fderivWithin ‚Ñù f s x).complexOfReal h‚ÇÇ
    rfl

```
**File:** Mathlib/Analysis/Complex/Conformal.lean (L281-289)
```text
The **Cauchy-Riemann Equation**: A real-differentiable function `f` on `‚ÑÇ` is complex-differentiable
at `x` if and only if the derivative `fderiv ‚Ñù f x` maps `I` to `I ‚Ä¢ (fderiv ‚Ñù f x) 1`.
-/
theorem differentiableAt_complex_iff_differentiableAt_real :
    DifferentiableAt ‚ÑÇ f x ‚Üî DifferentiableAt ‚Ñù f x ‚àß
      fderiv ‚Ñù f x I = I ‚Ä¢ fderiv ‚Ñù f x 1 :=
  ‚ü®fun h ‚Ü¶ by simp [h.restrictScalars ‚Ñù, h.fderiv_restrictScalars ‚Ñù],
    fun ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© ‚Ü¶ (differentiableAt_iff_restrictScalars ‚Ñù h‚ÇÅ).2
    ‚ü®(fderiv ‚Ñù f x).complexOfReal h‚ÇÇ, rfl‚ü©‚ü©
```
**File:** Mathlib/Analysis/Normed/Module/FiniteDimension.lean (L23-51)
```text
/-!
# Finite-dimensional normed spaces over complete fields

Over a complete nontrivially normed field, in finite dimension, all norms are equivalent and all
linear maps are continuous. Moreover, a finite-dimensional subspace is always complete and closed.

## Main results:

* `FiniteDimensional.complete` : a finite-dimensional space over a complete field is complete. This
  is not registered as an instance, as the field would be an unknown metavariable in typeclass
  resolution.
* `Submodule.closed_of_finiteDimensional` : a finite-dimensional subspace over a complete field is
  closed
* `FiniteDimensional.proper` : a finite-dimensional space over a proper field is proper. This
  is not registered as an instance, as the field would be an unknown metavariable in typeclass
  resolution. It is however registered as an instance for `ùïú = ‚Ñù` and `ùïú = ‚ÑÇ`. As properness
  implies completeness, there is no need to also register `FiniteDimensional.complete` on `‚Ñù` or
  `‚ÑÇ`.
* `FiniteDimensional.of_isCompact_closedBall`: Riesz' theorem: if the closed unit ball is
  compact, then the space is finite-dimensional.

## Implementation notes

The fact that all norms are equivalent is not written explicitly, as it would mean having two norms
on a single space, which is not the way type classes work. However, if one has a
finite-dimensional vector space `E` with a norm, and a copy `E'` of this type with another norm,
then the identities from `E` to `E'` and from `E'` to `E` are continuous thanks to
`LinearMap.continuous_of_finiteDimensional`. This gives the desired norm equivalence.
-/
```
**File:** Mathlib/Analysis/Analytic/Constructions.lean (L14-22)
```text
/-!
# Various ways to combine analytic functions

We show that the following are analytic:

1. Cartesian products of analytic functions
2. Arithmetic on analytic functions: `mul`, `smul`, `inv`, `div`
3. Finite sums and products: `Finset.sum`, `Finset.prod`
-/
```
**File:** docs/1000.yaml (L401-402)
```yaml
Q383238:
  title: Hartogs's extension theorem
```
**File:** docs/1000.yaml (L1213-1216)
```yaml
Q1050932:
  title: Hartogs's theorem
  url: https://github.com/girving/ray/blob/main/Ray/Hartogs/Hartogs.lean
  authors: Geoffrey Irving
```
## Q3
what about this axiom? Also: which one of the 3 axioms is the lower hanging fruit?

/-
Copyright (c) 2025 Michael R. Douglas, Sarah Hoback, Anna Mei, Ron Nissim. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Michael R. Douglas, Sarah Hoback, Anna Mei, Ron Nissim
-/

import Mathlib.Data.Complex.Basic
import Mathlib.Analysis.InnerProductSpace.Basic
import Mathlib.MeasureTheory.Measure.ProbabilityMeasure
import OSforGFF.PositiveDefinite
import OSforGFF.GaussianRBF
import Mathlib.Data.Finset.Basic
import Mathlib.Data.Fintype.Basic
import Mathlib.Algebra.BigOperators.Group.Finset.Basic
import Mathlib.Analysis.LocallyConvex.Basic
import Mathlib.Topology.Algebra.Module.WeakDual
import Mathlib.Analysis.Distribution.SchwartzSpace.Deriv
import OSforGFF.NuclearSpace
import Mathlib.Data.Matrix.Basic
import Mathlib.LinearAlgebra.Matrix.PosDef
import Mathlib.Analysis.InnerProductSpace.EuclideanDist
import Mathlib.Analysis.InnerProductSpace.PiL2

/-!
# Minlos Theorem and Gaussian Measure Construction

This file axiomatizes the Minlos theorem for nuclear spaces and builds the Gaussian measure
construction on top of it. (Legacy discussion: `NuclearSpace`.)
In the current proved GFF pipeline, the nuclearity gap is instead isolated as
`SchwartzNuclearInclusion` (see `OSforGFF/NuclearSpace/Schwartz.lean`).

## Main declarations

- `minlos_theorem`: Existence and uniqueness of probability measure from characteristic functional
- `minlos_uniqueness`: Derived uniqueness lemma for measures with a common CF
- `gaussian_characteristic_functional`: The Gaussian characteristic functional exp(-¬ΩC(f,f))
- `gaussian_rbf_pd_innerProduct`: Gaussian RBF is positive definite (proved in GaussianRBF.lean)
- `gaussian_positive_definite_via_embedding`: PD via Hilbert space embedding C(f,f) = ‚ÄñTf‚Äñ¬≤
- `minlos_gaussian_construction`: Applies Minlos to construct Gaussian measure from covariance
- `gaussian_measure_characteristic_functional`: Same, returning ProbabilityMeasure
- `gaussian_measure_symmetry`: Covariance-preserving maps induce measure symmetries
-/

open Complex MeasureTheory Matrix
open BigOperators

noncomputable section

/-! ## Axioms in this file

This file declares one axiom (see `old/texts/axioms.md` for justification):
- `minlos_theorem`: Minlos theorem (existence and uniqueness) for nuclear spaces
  (Gel'fand-Vilenkin Vol. 4, Billingsley)

The remaining Schwartz nuclearity hypothesis is packaged as `SchwartzNuclearInclusion` in
`OSforGFF/NuclearSpace/Schwartz.lean` (and implies `NuclearSpaceStd TestFunction`).
The Gaussian RBF positive-definiteness is proved in `OSforGFF.GaussianRBF`.
-/

/-! ## Minlos Theorem -/

variable {E : Type*} [AddCommGroup E] [Module ‚Ñù E] [TopologicalSpace E]

-- We need a measurable space structure on the weak dual
instance : MeasurableSpace (WeakDual ‚Ñù E) := borel _

/-- **Minlos Theorem** (existence and uniqueness): On a nuclear locally convex space E,
    a continuous, positive definite, normalized functional Œ¶ : E ‚Üí ‚ÑÇ is the characteristic
    functional of a unique probability measure Œº on the topological dual E':

    Œ¶(f) = ‚à´_{E'} exp(i‚ü®f,œâ‚ü©) dŒº(œâ)

    **Applications**:
    - For E = S(‚Ñù·µà) (Schwartz space), E' = S'(‚Ñù·µà) (tempered distributions)
    - Gaussian measures: Œ¶(f) = exp(-¬Ω‚ü®f, Cf‚ü©) with nuclear covariance C
    - Construction of the Gaussian Free Field

    **References**: Minlos (1959), Gel'fand-Vilenkin Vol. 4, Billingsley. -/
-- (historical placeholder; removed from Lean code) minlos_theorem
  [NuclearSpace E]
  (Œ¶ : E ‚Üí ‚ÑÇ)
  (h_continuous : Continuous Œ¶)
  (h_positive_definite : IsPositiveDefinite Œ¶)
  (h_normalized : Œ¶ 0 = 1) :
  ‚àÉ! Œº : ProbabilityMeasure (WeakDual ‚Ñù E),
    ‚àÄ f : E, Œ¶ f = ‚à´ œâ, Complex.exp (I * (œâ f)) ‚àÇŒº.toMeasure
### Answer
# Analysis of mathlib4 API for Advanced Probability and Functional Analysis

## (1) Minlos Theorem and Characteristic Functionals

**Note:** The Minlos theorem itself is not explicitly formalized in mathlib4. However, the core mathematical infrastructure exists:

### Characteristic Functions
Mathlib4 defines characteristic functions for measures on both inner product spaces and normed spaces: mathlib4:128-128 mathlib4:324-324 

### Extension Theorems (Core of Minlos)
The key result showing that characteristic functions uniquely determine finite measures: mathlib4:236-243 mathlib4:442-445 

These theorems establish that if two finite measures have identical characteristic functions, they are equal - the fundamental principle underlying Minlos' theorem.

## (2) Positive Definite Functionals

### Linear Operators mathlib4:56-59 mathlib4:90-94 

### Bilinear Forms
Positive semidefinite bilinear forms are characterized through the `IsPosSemidef` predicate: mathlib4:87-89 

This is used extensively in the Gaussian measure characterization.

## (3) Gaussian Measures and Characteristic Functionals

Mathlib4 has excellent infrastructure for Gaussian measures:

### Definition mathlib4:44-47 

### Characterization via Characteristic Functions
The main characterization theorem in Banach spaces: mathlib4:63-82 

For Hilbert spaces: mathlib4:144-163 

### Uniqueness
Gaussian measures are uniquely determined by mean and covariance: mathlib4:116-122 

## (4) Probability Measures on Weak Duals of Locally Convex Spaces

### Weak Dual Topology mathlib4:1-50 

### Locally Convex Spaces
The topology induced by seminorm families: mathlib4:16-58 

### Probability Measures with Weak Convergence
The weak convergence topology on probability measures is defined by embedding into the weak dual: mathlib4:1-50 

## (5) Covariance Operators and Gaussian Measures

### Covariance Bilinear Forms mathlib4:14-36 

### Relationship to Gaussian Measures
The covariance bilinear form uniquely determines a Gaussian measure (together with the mean): mathlib4:56-61 mathlib4:68-70 

## Infrastructure Comparison for Three Theorems

### 1. **Schwartz_nuclear (Nuclear Spaces)** - **MINIMAL SUPPORT**
**Nuclear spaces are NOT implemented in mathlib4.** A grep search finds no definitions of nuclear spaces in the functional analysis sense. However, the Schwartz space is well-developed: mathlib4:20-67 

The Schwartz space has ~1500 lines of formalization including seminorms, topology, derivatives, and integration.

### 2. **Differentiable_analyticAt_finDim (Goursat/Hartogs)** - **MODERATE SUPPORT**
**Hartogs's theorem is NOT in mathlib4** but exists as an external formalization: mathlib4:1213-1216 

However, mathlib4 has substantial infrastructure for analytic functions:
- Basic analytic function theory mathlib4:1-50 

- Separate analyticity via currying: mathlib4:1-50 

### 3. **Minlos_theorem** - **STRONGEST SUPPORT**
While not explicitly named, the mathematical content is substantially present:

- ‚úì Characteristic functions on normed/inner product spaces
- ‚úì Extension theorems (measures equal if characteristic functions equal)
- ‚úì Gaussian measures fully characterized via characteristic functionals
- ‚úì Positive semidefinite bilinear forms
- ‚úì Covariance operators
- ‚úì Weak dual topology and locally convex spaces
- ‚úì Tempered distributions (dual of Schwartz space) mathlib4:17-51 

## Conclusion

**Ranking by infrastructure support:**

1. **Minlos theorem** (BEST) - Core components are formalized: characteristic functions, extension theorems, Gaussian characterization, positive semidefinite forms, covariance operators, and weak dual topology. Only missing: explicit statement on infinite-dimensional spaces and tightness conditions.

2. **Hartogs theorem** (MODERATE) - Analytic function infrastructure exists with product spaces and separate analyticity. External formalization available. Missing: formal integration into mathlib4.

3. **Nuclear spaces** (WEAKEST) - No implementation of nuclear spaces. Only the Schwartz space (a specific nuclear space) is formalized, but without the general nuclear space framework.

## Notes

- The characteristic function infrastructure in mathlib4 is recent (2024-2025) and quite comprehensive.
- Gaussian measures are characterized completely via characteristic functionals with uniqueness results.
- The Schwartz space and tempered distributions provide a pathway toward Minlos-type results, but explicit formalization of the theorem on infinite-dimensional spaces is absent.
- Bochner's theorem on positive definite functions is not explicitly formalized, though the Bochner integral exists.
### Citations
**File:** Mathlib/MeasureTheory/Measure/CharacteristicFunction.lean (L17-51)
```text
/-!
# Characteristic Function of a Finite Measure

This file defines the characteristic function of a finite measure on a topological vector space `V`.

The characteristic function of a finite measure `P` on `V` is the mapping
`W ‚Üí ‚ÑÇ, w => ‚à´ v, e (L v w) ‚àÇP`,
where `e` is a continuous additive character and `L : V ‚Üí‚Çó[‚Ñù] W ‚Üí‚Çó[‚Ñù] ‚Ñù` is a bilinear map.

A typical example is `V = W = ‚Ñù` and `L v w = v * w`.

The integral is expressed as `‚à´ v, char he hL w v ‚àÇP`, where `char he hL w` is the
bounded continuous function `fun v ‚Ü¶ e (L v w)` and `he`, `hL` are continuity hypotheses on `e`
and `L`.

## Main definitions

* `innerProbChar`: the bounded continuous map `x ‚Ü¶ exp(‚ü™x, t‚ü´ * I)` in an inner product space.
  This is `char` for the inner product bilinear map and the additive character `e = probChar`.
* `charFun Œº t`: the characteristic function of a measure `Œº` at `t` in an inner product space `E`.
  This is defined as `‚à´ x, exp (‚ü™x, t‚ü´ * I) ‚àÇŒº`, where `‚ü™x, t‚ü´` is the inner product on `E`.
  It is equal to `‚à´ v, innerProbChar w v ‚àÇP` (see `charFun_eq_integral_innerProbChar`).
* `probCharDual`: the bounded continuous map `x ‚Ü¶ exp (L x * I)`, for a continuous linear form `L`.
* `charFunDual Œº L`: the characteristic function of a measure `Œº` at `L : Dual ‚Ñù E` in
  a normed space `E`. This is the integral `‚à´ v, exp (L v * I) ‚àÇŒº`.

## Main statements

* `ext_of_integral_char_eq`: Assume `e` and `L` are non-trivial. If the integrals of `char`
  with respect to two finite measures `P` and `P'` coincide, then `P = P'`.
* `Measure.ext_of_charFun`: If the characteristic functions `charFun` of two finite measures
  `Œº` and `ŒΩ` on a complete second-countable inner product space coincide, then `Œº = ŒΩ`.
* `Measure.ext_of_charFunDual`: If the characteristic functions `charFunDual` of two finite measures
  `Œº` and `ŒΩ` on a Banach space coincide, then `Œº = ŒΩ`.

```
**File:** Mathlib/MeasureTheory/Measure/CharacteristicFunction.lean (L128-128)
```text
noncomputable def charFun [Inner ‚Ñù E] (Œº : Measure E) (t : E) : ‚ÑÇ := ‚à´ x, exp (‚ü™x, t‚ü´ * I) ‚àÇŒº
```
**File:** Mathlib/MeasureTheory/Measure/CharacteristicFunction.lean (L236-243)
```text
theorem Measure.ext_of_charFun [CompleteSpace E]
    [IsFiniteMeasure Œº] [IsFiniteMeasure ŒΩ] (h : charFun Œº = charFun ŒΩ) :
    Œº = ŒΩ := by
  simp_rw [funext_iff, charFun_eq_integral_innerProbChar] at h
  refine ext_of_integral_char_eq continuous_probChar probChar_ne_one (L := inner‚Çó E)
    ?_ ?_ h
  ¬∑ exact fun v hv ‚Ü¶ DFunLike.ne_iff.mpr ‚ü®v, inner_self_ne_zero.mpr hv‚ü©
  ¬∑ exact continuous_inner
```
**File:** Mathlib/MeasureTheory/Measure/CharacteristicFunction.lean (L324-324)
```text
def charFunDual (Œº : Measure E) (L : StrongDual ‚Ñù E) : ‚ÑÇ := ‚à´ v, probCharDual L v ‚àÇŒº
```
**File:** Mathlib/MeasureTheory/Measure/CharacteristicFunction.lean (L442-445)
```text
theorem Measure.ext_of_charFunDual [CompleteSpace E]
    {Œº ŒΩ : Measure E} [IsFiniteMeasure Œº] [IsFiniteMeasure ŒΩ]
    (h : charFunDual Œº = charFunDual ŒΩ) :
    Œº = ŒΩ := by
```
**File:** Mathlib/Analysis/InnerProductSpace/Positive.lean (L56-59)
```text
/-- A linear operator `T` on a Hilbert space is **positive** if it is symmetric and
  `‚àÄ x, 0 ‚â§ re ‚ü™T x, x‚ü´`. -/
def IsPositive (T : E ‚Üí‚Çó[ùïú] E) : Prop :=
  IsSymmetric T ‚àß ‚àÄ x, 0 ‚â§ re ‚ü™T x, x‚ü´
```
**File:** Mathlib/Analysis/InnerProductSpace/Positive.lean (L90-94)
```text
theorem isPositive_iff (T : E ‚Üí‚Çó[ùïú] E) :
    IsPositive T ‚Üî IsSymmetric T ‚àß ‚àÄ x, 0 ‚â§ ‚ü™T x, x‚ü´ := by
  simp_rw [IsPositive, and_congr_right_iff, ‚Üê RCLike.ofReal_nonneg (K := ùïú)]
  intro hT
  simp [hT]
```
**File:** Mathlib/LinearAlgebra/BilinearForm/Properties.lean (L87-89)
```text
/-- The proposition that a bilinear form is symmetric -/
structure IsSymm (B : BilinForm R M) : Prop where
  protected eq : ‚àÄ x y, B x y = B y x
```
**File:** Mathlib/Probability/Distributions/Gaussian/Basic.lean (L44-47)
```text
/-- A measure is Gaussian if its map by every continuous linear form is a real Gaussian measure. -/
class IsGaussian {E : Type*} [TopologicalSpace E] [AddCommMonoid E] [Module ‚Ñù E]
    {mE : MeasurableSpace E} (Œº : Measure E) : Prop where
  map_eq_gaussianReal (L : StrongDual ‚Ñù E) : Œº.map L = gaussianReal (Œº[L]) (Var[L; Œº]).toNNReal
```
**File:** Mathlib/Probability/Distributions/Gaussian/CharFun.lean (L56-61)
```text
lemma IsGaussian.charFunDual_eq' [IsGaussian Œº] (L : StrongDual ‚Ñù E) :
    charFunDual Œº L = exp ((L Œº[id]) * I - covarianceBilinDual Œº L L / 2) := by
  rw [IsGaussian.charFunDual_eq, covarianceBilinDual_self_eq_variance, integral_complex_ofReal,
    L.integral_comp_id_comm']
  ¬∑ exact IsGaussian.integrable_id
  ¬∑ exact IsGaussian.memLp_two_id
```
**File:** Mathlib/Probability/Distributions/Gaussian/CharFun.lean (L63-82)
```text
/-- The measure `Œº` is Gaussian if and only if there
exist `m : E` and `f : StrongDual ‚Ñù E ‚ÜíL[‚Ñù] StrongDual ‚Ñù E ‚ÜíL[‚Ñù] ‚Ñù`
satisfying `f.toBilinForm.IsPosSemidef` and `charFunDual Œº L = exp (L m * I - f L L / 2)`. -/
lemma isGaussian_iff_gaussian_charFunDual [IsFiniteMeasure Œº] :
    IsGaussian Œº ‚Üî
    ‚àÉ (m : E) (f : StrongDual ‚Ñù E ‚ÜíL[‚Ñù] StrongDual ‚Ñù E ‚ÜíL[‚Ñù] ‚Ñù),
      f.toBilinForm.IsPosSemidef ‚àß ‚àÄ L, charFunDual Œº L = exp (L m * I - f L L / 2) := by
  refine ‚ü®fun h ‚Ü¶ ‚ü®Œº[id], covarianceBilinDual Œº, isPosSemidef_covarianceBilinDual,
    h.charFunDual_eq'‚ü©,
    fun ‚ü®m, f, hf, h‚ü© ‚Ü¶ isGaussian_of_map_eq_gaussianReal fun L ‚Ü¶ ‚ü®L m, (f L L).toNNReal, ?_‚ü©‚ü©
  apply Measure.ext_of_charFun
  ext t
  simp_rw [charFun_map_eq_charFunDual_smul, h, charFun_gaussianReal,
    smul_apply, map_smul, smul_apply, smul_eq_mul]
  norm_cast
  congrm exp (_ - ofReal ?_)
  rw [Real.coe_toNNReal]
  ¬∑ ring
  exact hf.nonneg L

```
**File:** Mathlib/Probability/Distributions/Gaussian/CharFun.lean (L116-122)
```text
/-- Two Gaussian measures are equal if they have same mean and same covariance. -/
protected lemma IsGaussian.ext_covarianceBilinDual {ŒΩ : Measure E} [IsGaussian Œº] [IsGaussian ŒΩ]
    (hm : Œº[id] = ŒΩ[id]) (hv : covarianceBilinDual Œº = covarianceBilinDual ŒΩ) : Œº = ŒΩ := by
  apply Measure.ext_of_charFunDual
  ext L
  simp_rw [IsGaussian.charFunDual_eq', hm, hv]

```
**File:** Mathlib/Probability/Distributions/Gaussian/CharFun.lean (L144-163)
```text
/-- The measure `Œº` is Gaussian if and only if there
exist `m : E` and `f : E ‚ÜíL[‚Ñù]  E ‚ÜíL[‚Ñù] ‚Ñù`
satisfying `f.toBilinForm.IsPosSemidef` and `charFun Œº t = exp (‚ü™t, m‚ü´ * I - f t t / 2)`. -/
lemma isGaussian_iff_gaussian_charFun [IsFiniteMeasure Œº] :
    IsGaussian Œº ‚Üî
    ‚àÉ (m : E) (f : E ‚ÜíL[‚Ñù] E ‚ÜíL[‚Ñù] ‚Ñù),
      f.toBilinForm.IsPosSemidef ‚àß ‚àÄ t, charFun Œº t = exp (‚ü™t, m‚ü´ * I - f t t / 2) := by
  rw [isGaussian_iff_gaussian_charFunDual]
  refine ‚ü®fun ‚ü®m, f, hf, h‚ü© ‚Ü¶ ‚ü®m,
    f.bilinearComp (InnerProductSpace.toDualMap ‚Ñù E).toContinuousLinearMap
      (InnerProductSpace.toDualMap ‚Ñù E).toContinuousLinearMap,
    ‚ü®‚ü®fun x y ‚Ü¶ ?_‚ü©, ‚ü®fun x ‚Ü¶ ?_‚ü©‚ü©, ?_‚ü©,
    fun ‚ü®m, f, hf, h‚ü© ‚Ü¶ ‚ü®m,
      f.bilinearComp (InnerProductSpace.toDual ‚Ñù E).symm.toLinearIsometry.toContinuousLinearMap
        (InnerProductSpace.toDual ‚Ñù E).symm.toLinearIsometry.toContinuousLinearMap,
    ‚ü®‚ü®fun x y ‚Ü¶ ?_‚ü©, ‚ü®fun x ‚Ü¶ ?_‚ü©‚ü©, ?_‚ü©‚ü©
  any_goals simpa using hf.eq ..
  any_goals simpa using hf.nonneg _
  ¬∑ simp [charFun_eq_charFunDual_toDualMap, h, -InnerProductSpace.toContinuousLinearMap_toDualMap]
  ¬∑ simp [‚Üê charFun_toDual_symm_eq_charFunDual, h]
```
**File:** Mathlib/Analysis/LocallyConvex/WeakDual.lean (L1-50)
```text
/-
Copyright (c) 2022 Moritz Doll. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Moritz Doll
-/
module

public import Mathlib.Analysis.Normed.Field.Lemmas
public import Mathlib.Analysis.LocallyConvex.WithSeminorms
public import Mathlib.LinearAlgebra.Dual.Lemmas
public import Mathlib.LinearAlgebra.Finsupp.Span
public import Mathlib.Topology.Algebra.Module.WeakBilin

/-!
# Weak Dual in Topological Vector Spaces

We prove that the weak topology induced by a bilinear form `B : E ‚Üí‚Çó[ùïú] F ‚Üí‚Çó[ùïú] ùïú` is locally
convex and we explicitly give a neighborhood basis in terms of the family of seminorms
`fun x => ‚ÄñB x y‚Äñ` for `y : F`.

## Main definitions

* `LinearMap.toSeminorm`: turn a linear form `f : E ‚Üí‚Çó[ùïú] ùïú` into a seminorm `fun x => ‚Äñf x‚Äñ`.
* `LinearMap.toSeminormFamily`: turn a bilinear form `B : E ‚Üí‚Çó[ùïú] F ‚Üí‚Çó[ùïú] ùïú` into a map
  `F ‚Üí Seminorm ùïú E`.

## Main statements

* `LinearMap.hasBasis_weakBilin`: the seminorm balls of `B.toSeminormFamily` form a
  neighborhood basis of `0` in the weak topology.
* `LinearMap.toSeminormFamily.withSeminorms`: the topology of a weak space is induced by the
  family of seminorms `B.toSeminormFamily`.
* `WeakBilin.locallyConvexSpace`: a space endowed with a weak topology is locally convex.

## References

* [Bourbaki, *Topological Vector Spaces*][bourbaki1987]
* [Rudin, *Functional Analysis*][rudin1991]

## Tags

weak dual, seminorm
-/

@[expose] public section


variable {ùïú E F : Type*}

open Topology
```
**File:** Mathlib/Analysis/LocallyConvex/WithSeminorms.lean (L16-58)
```text
/-!
# Topology induced by a family of seminorms

## Main definitions

* `SeminormFamily.basisSets`: The set of open seminorm balls for a family of seminorms.
* `SeminormFamily.moduleFilterBasis`: A module filter basis formed by the open balls.
* `Seminorm.IsBounded`: A linear map `f : E ‚Üí‚Çó[ùïú] F` is bounded iff every seminorm in `F` can be
  bounded by a finite number of seminorms in `E`.
* `WithSeminorms p`, when `p` is a family of seminorms on `E`, is a proposition expressing that the
  (existing) topology on `E` is induced by the seminorms `p`.
* `PolynormableSpace ùïú E` is a class asserting that the (existing) topology on `E` is induced
  by *some* family of `ùïú`-seminorms. If `ùïú` is `RCLike`, this is equivalent to
  `LocallyConvexSpace ùïú E`.
  The terminology is inspired by N. Bourbaki, *Vari√©t√©s diff√©rentielles et analytiques*. However,
  unlike Bourbaki, we do not ask seminorms to be ultrametric when `ùïú` is ultrametric.

## Main statements

* `WithSeminorms.toLocallyConvexSpace`: A space equipped with a family of seminorms is locally
  convex.
* `WithSeminorms.firstCountable`: A space is first countable if its topology is induced by a
  countable family of seminorms.

## Continuity of semilinear maps

If `E` and `F` are topological vector space with the topology induced by a family of seminorms, then
we have a direct method to prove that a linear map is continuous:
* `Seminorm.continuous_from_bounded`: A bounded linear map `f : E ‚Üí‚Çó[ùïú] F` is continuous.

If the topology of a space `E` is induced by a family of seminorms, then we can characterize von
Neumann boundedness in terms of that seminorm family. Together with
`LinearMap.continuous_of_locally_bounded` this gives general criterion for continuity.

* `WithSeminorms.isVonNBounded_iff_finset_seminorm_bounded`
* `WithSeminorms.isVonNBounded_iff_seminorm_bounded`
* `WithSeminorms.image_isVonNBounded_iff_finset_seminorm_bounded`
* `WithSeminorms.image_isVonNBounded_iff_seminorm_bounded`

## Tags

seminorm, locally convex
-/
```
**File:** Mathlib/MeasureTheory/Measure/FiniteMeasure.lean (L1-50)
```text
/-
Copyright (c) 2021 Kalle Kyt√∂l√§. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kalle Kyt√∂l√§
-/
module

public import Mathlib.Analysis.RCLike.Lemmas
public import Mathlib.MeasureTheory.Integral.Bochner.ContinuousLinearMap
public import Mathlib.MeasureTheory.Measure.HasOuterApproxClosed
public import Mathlib.MeasureTheory.Measure.Prod
public import Mathlib.Topology.Algebra.Module.WeakDual
public import Mathlib.Topology.TietzeExtension

/-!
# Finite measures

This file defines the type of finite measures on a given measurable space. When the underlying
space has a topology and the measurable space structure (sigma algebra) is finer than the Borel
sigma algebra, then the type of finite measures is equipped with the topology of weak convergence
of measures. The topology of weak convergence is the coarsest topology w.r.t. which
for every bounded continuous `‚Ñù‚â•0`-valued function `f`, the integration of `f` against the
measure is continuous.

## Main definitions

The main definitions are
* `MeasureTheory.FiniteMeasure Œ©`: The type of finite measures on `Œ©` with the topology of weak
  convergence of measures.
* `MeasureTheory.FiniteMeasure.toWeakDualBCNN : FiniteMeasure Œ© ‚Üí (WeakDual ‚Ñù‚â•0 (Œ© ‚Üí·µá ‚Ñù‚â•0))`:
  Interpret a finite measure as a continuous linear functional on the space of
  bounded continuous nonnegative functions on `Œ©`. This is used for the definition of the
  topology of weak convergence.
* `MeasureTheory.FiniteMeasure.map`: The push-forward `f* Œº` of a finite measure `Œº` on `Œ©`
  along a measurable function `f : Œ© ‚Üí Œ©'`.
* `MeasureTheory.FiniteMeasure.mapCLM`: The push-forward along a given continuous `f : Œ© ‚Üí Œ©'`
  as a continuous linear map `f* : FiniteMeasure Œ© ‚ÜíL[‚Ñù‚â•0] FiniteMeasure Œ©'`.

## Main results

* Finite measures `Œº` on `Œ©` give rise to continuous linear functionals on the space of
  bounded continuous nonnegative functions on `Œ©` via integration:
  `MeasureTheory.FiniteMeasure.toWeakDualBCNN : FiniteMeasure Œ© ‚Üí (WeakDual ‚Ñù‚â•0 (Œ© ‚Üí·µá ‚Ñù‚â•0))`
* `MeasureTheory.FiniteMeasure.tendsto_iff_forall_integral_tendsto`: Convergence of finite
  measures is characterized by the convergence of integrals of all bounded continuous functions.
  This shows that the chosen definition of topology coincides with the common textbook definition
  of weak convergence of measures. A similar characterization by the convergence of integrals (in
  the `MeasureTheory.lintegral` sense) of all bounded continuous nonnegative functions is
  `MeasureTheory.FiniteMeasure.tendsto_iff_forall_lintegral_tendsto`.
* `MeasureTheory.FiniteMeasure.continuous_map`: For a continuous function `f : Œ© ‚Üí Œ©'`, the
```
**File:** Mathlib/Probability/Moments/CovarianceBilin.lean (L14-36)
```text
/-!
# Covariance in Hilbert spaces

Given a measure `Œº` defined over a Banach space `E`, one can consider the associated covariance
bilinear form which maps `L‚ÇÅ L‚ÇÇ : StrongDual ‚Ñù E` to `cov[L‚ÇÅ, L‚ÇÇ; Œº]`. This is called
`covarianceBilinDual Œº` and is defined in the `CovarianceBilinDual` file.

In the special case where `E` is a Hilbert space, each `L : StrongDual ‚Ñù E` can be represented
as the scalar product against some element of `E`. This motivates the definition of
`covarianceBilin`, which is a continuous bilinear form mapping `x y : E` to
`cov[‚ü™x, ¬∑‚ü´, ‚ü™y, ¬∑‚ü´; Œº]`.

## Main definitions

* `covarianceBilin Œº`: the continuous bilinear form over `E` representing the covariance of a
  measure over `E`.
* `covarianceOperator Œº`: the bounded operator over `E` such that
  `‚ü™covarianceOperator Œº x, y‚ü´ = ‚à´ z, ‚ü™x, z‚ü´ * ‚ü™y, z‚ü´ ‚àÇŒº`.

## Tags

covariance, Hilbert space, bilinear form
-/
```
**File:** Mathlib/Probability/Moments/CovarianceBilin.lean (L68-70)
```text
lemma covarianceBilin_apply [CompleteSpace E] [IsFiniteMeasure Œº] (h : MemLp id 2 Œº) (x y : E) :
    covarianceBilin Œº x y = ‚à´ z, ‚ü™x, z - Œº[id]‚ü´ * ‚ü™y, z - Œº[id]‚ü´ ‚àÇŒº := by
  simp [covarianceBilin, covarianceBilinDual_apply' h]
```
**File:** Mathlib/Analysis/Distribution/SchwartzSpace.lean (L20-67)
```text
/-!
# Schwartz space

This file defines the Schwartz space. Usually, the Schwartz space is defined as the set of smooth
functions $f : ‚Ñù^n ‚Üí ‚ÑÇ$ such that there exists $C_{Œ±Œ≤} > 0$ with $$|x^Œ± ‚àÇ^Œ≤ f(x)| < C_{Œ±Œ≤}$$ for
all $x ‚àà ‚Ñù^n$ and for all multiindices $Œ±, Œ≤$.
In mathlib, we use a slightly different approach and define the Schwartz space as all
smooth functions `f : E ‚Üí F`, where `E` and `F` are real normed vector spaces such that for all
natural numbers `k` and `n` we have uniform bounds `‚Äñx‚Äñ^k * ‚ÄñiteratedFDeriv ‚Ñù n f x‚Äñ < C`.
This approach completely avoids using partial derivatives as well as polynomials.
We construct the topology on the Schwartz space by a family of seminorms, which are the best
constants in the above estimates. The abstract theory of topological vector spaces developed in
`SeminormFamily.moduleFilterBasis` and `WithSeminorms.toLocallyConvexSpace` turns the
Schwartz space into a locally convex topological vector space.

## Main definitions

* `SchwartzMap`: The Schwartz space is the space of smooth functions such that all derivatives
  decay faster than any power of `‚Äñx‚Äñ`.
* `SchwartzMap.seminorm`: The family of seminorms as described above
* `SchwartzMap.compCLM`: Composition with a function on the right as a continuous linear map
  `ùì¢(E, F) ‚ÜíL[ùïú] ùì¢(D, F)`, provided that the function is temperate and grows polynomially near
  infinity
* `SchwartzMap.fderivCLM`: The differential as a continuous linear map
  `ùì¢(E, F) ‚ÜíL[ùïú] ùì¢(E, E ‚ÜíL[‚Ñù] F)`
* `SchwartzMap.derivCLM`: The one-dimensional derivative as a continuous linear map
  `ùì¢(‚Ñù, F) ‚ÜíL[ùïú] ùì¢(‚Ñù, F)`
* `SchwartzMap.integralCLM`: Integration as a continuous linear map `ùì¢(‚Ñù, F) ‚ÜíL[‚Ñù] F`

## Main statements

* `SchwartzMap.instIsUniformAddGroup` and `SchwartzMap.instLocallyConvexSpace`: The Schwartz space
  is a locally convex topological vector space.
* `SchwartzMap.one_add_le_sup_seminorm_apply`: For a Schwartz function `f` there is a uniform bound
  on `(1 + ‚Äñx‚Äñ) ^ k * ‚ÄñiteratedFDeriv ‚Ñù n f x‚Äñ`.

## Implementation details

The implementation of the seminorms is taken almost literally from `ContinuousLinearMap.opNorm`.

## Notation

* `ùì¢(E, F)`: The Schwartz space `SchwartzMap E F` localized in `SchwartzSpace`

## Tags

Schwartz space, tempered distributions
-/
```
**File:** docs/1000.yaml (L1213-1216)
```yaml
Q1050932:
  title: Hartogs's theorem
  url: https://github.com/girving/ray/blob/main/Ray/Hartogs/Hartogs.lean
  authors: Geoffrey Irving
```
**File:** Mathlib/Analysis/Analytic/Basic.lean (L1-50)
```text
/-
Copyright (c) 2020 S√©bastien Gou√´zel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: S√©bastien Gou√´zel, Yury Kudryashov
-/
module

public import Mathlib.Analysis.Analytic.ConvergenceRadius
public import Mathlib.Topology.Algebra.InfiniteSum.Module

/-!
# Analytic functions

A function is analytic in one dimension around `0` if it can be written as a converging power series
`Œ£ p‚Çô z‚Åø`. This definition can be extended to any dimension (even in infinite dimension) by
requiring that `p‚Çô` is a continuous `n`-multilinear map. In general, `p‚Çô` is not unique (in two
dimensions, taking `p‚ÇÇ (x, y) (x', y') = x y'` or `y x'` gives the same map when applied to a
vector `(x, y) (x, y)`). A way to guarantee uniqueness is to take a symmetric `p‚Çô`, but this is not
always possible in nonzero characteristic (in characteristic 2, the previous example has no
symmetric representative). Therefore, we do not insist on symmetry or uniqueness in the definition,
and we only require the existence of a converging series.

The general framework is important to say that the exponential map on bounded operators on a Banach
space is analytic, as well as the inverse on invertible operators.

## Main definitions

Let `p` be a formal multilinear series from `E` to `F`, i.e., `p n` is a multilinear map on `E^n`
for `n : ‚Ñï`.

* `HasFPowerSeriesOnBall f p x r`: on the ball of center `x` with radius `r`,
  `f (x + y) = ‚àë'_n p‚Çô y‚Åø`.
* `HasFPowerSeriesAt f p x`: on some ball of center `x` with positive radius, holds
  `HasFPowerSeriesOnBall f p x r`.
* `AnalyticAt ùïú f x`: there exists a power series `p` such that holds `HasFPowerSeriesAt f p x`.
* `AnalyticOnNhd ùïú f s`: the function `f` is analytic at every point of `s`.

We also define versions of `HasFPowerSeriesOnBall`, `AnalyticAt`, and `AnalyticOnNhd` restricted to
a set, similar to `ContinuousWithinAt`.
See `Mathlib/Analysis/Analytic/Within.lean` for basic properties.

* `AnalyticWithinAt ùïú f s x` means a power series at `x` converges to `f` on `ùìù[s ‚à™ {x}] x`.
* `AnalyticOn ùïú f s t` means `‚àÄ x ‚àà t, AnalyticWithinAt ùïú f s x`.

We develop the basic properties of these notions, notably:
* If a function admits a power series, it is continuous (see
  `HasFPowerSeriesOnBall.continuousOn` and `HasFPowerSeriesAt.continuousAt` and
  `AnalyticAt.continuousAt`).
* In a complete space, the sum of a formal power series with positive radius is well defined on the
  disk of convergence, see `FormalMultilinearSeries.hasFPowerSeriesOnBall`.
```
**File:** Mathlib/Analysis/Analytic/Constructions.lean (L1-50)
```text
/-
Copyright (c) 2023 Geoffrey Irving. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Loeffler, Geoffrey Irving, Stefan Kebekus
-/
module

public import Mathlib.Analysis.Analytic.Composition
public import Mathlib.Analysis.Analytic.Linear
public import Mathlib.Analysis.Normed.Operator.Mul
public import Mathlib.Analysis.Normed.Ring.Units
public import Mathlib.Analysis.Analytic.OfScalars

/-!
# Various ways to combine analytic functions

We show that the following are analytic:

1. Cartesian products of analytic functions
2. Arithmetic on analytic functions: `mul`, `smul`, `inv`, `div`
3. Finite sums and products: `Finset.sum`, `Finset.prod`
-/

@[expose] public section

noncomputable section

open scoped Topology
open Filter Asymptotics ENNReal NNReal

variable {Œ± : Type*}
variable {ùïú : Type*} [NontriviallyNormedField ùïú]
variable {E F G H : Type*} [NormedAddCommGroup E] [NormedSpace ùïú E] [NormedAddCommGroup F]
  [NormedSpace ùïú F] [NormedAddCommGroup G] [NormedSpace ùïú G] [NormedAddCommGroup H]
  [NormedSpace ùïú H]

variable {ùïù : Type*} [NontriviallyNormedField ùïù] [NormedAlgebra ùïú ùïù]
variable {A : Type*} [NormedRing A] [NormedAlgebra ùïú A]

/-!
### Constants are analytic
-/

theorem hasFPowerSeriesOnBall_const {c : F} {e : E} :
    HasFPowerSeriesOnBall (fun _ => c) (constFormalMultilinearSeries ùïú E c) e ‚ä§ := by
  refine ‚ü®by simp, WithTop.top_pos, fun _ => hasSum_single 0 fun n hn => ?_‚ü©
  simp [constFormalMultilinearSeries_apply_of_nonzero hn]

theorem hasFPowerSeriesAt_const {c : F} {e : E} :
    HasFPowerSeriesAt (fun _ => c) (constFormalMultilinearSeries ùïú E c) e :=
```
## Q4
now assess whether the 3 axioms are true and provable as stated and whether they are collectively consistent
### Answer
Based on my search of the mathlib4 repository, I can provide the following assessment of these three mathematical statements:

## (1) Schwartz Space as a Nuclear Space

**Status in mathlib4**: The Schwartz space is defined and equipped with a locally convex topology via seminorms, but the nuclear property is **not yet formalized**.

The Schwartz space `ùì¢(E, F)` is defined as smooth functions with rapid decay, equipped with a family of seminorms `schwartzSeminormFamily`. mathlib4:80-88 

The space is proven to be a locally convex topological vector space mathlib4:528-529  and has a first countable topology mathlib4:531-532 , but there is no formalization of nuclear spaces or the nuclear property (characterized by Hilbert-Schmidt embeddings between Hilbert spaces in the seminorm family).

**Mathematical correctness**: Statement (1) is mathematically true in functional analysis, but this specific characterization is not yet formalized in mathlib4.

## (2) Complex Differentiability Implies Analyticity

**Status in mathlib4**: **Fully formalized and proven**.

The equivalence between complex differentiability and analyticity on open sets is established: mathlib4:669-677 

Key theorems include:
- `analyticOnNhd_iff_differentiableOn`: On an open set, a function is analytic if and only if it is differentiable mathlib4:669-671 
- `analyticOn_iff_differentiableOn`: Similar equivalence for `AnalyticOn` mathlib4:674-677 
- `Differentiable.analyticAt`: A complex differentiable function is analytic at every point mathlib4:651-653 

The forward direction (analytic ‚Üí differentiable) is proven without completeness assumptions: mathlib4:126-127 

**Mathematical correctness**: Statement (2) is correct for complex functions on open sets in `‚ÑÇ‚Åø`. However, note that this is specifically about **Goursat's theorem** (that complex differentiability implies analyticity), not Hartogs' theorem (which is about separate analyticity implying joint analyticity). Hartogs' theorem is **not formalized** in mathlib4.

## (3) Minlos Theorem

**Status in mathlib4**: **Not formalized**.

While the codebase contains extensive infrastructure for characteristic functions and probability measures:
- Characteristic functions for finite measures are defined mathlib4:1-50 
- Probability measures are defined via `IsProbabilityMeasure` mathlib4:1-50 

However, Minlos theorem itself (the Minlos-Sazonov theorem) is not formalized. This theorem requires:
- Nuclear locally convex spaces (not formalized)
- The weak dual topology (not explicitly formalized for infinite-dimensional spaces)
- The characterization of continuous positive definite functionals

**Mathematical correctness**: Statement (3) is mathematically true and is a fundamental result in infinite-dimensional probability theory, but it requires formalizing concepts not yet in mathlib4.

## Consistency and Coexistence

**Mathematical assessment**: All three statements are true theorems in functional analysis and probability theory, and they are logically consistent with each other. When applied to Gaussian measures on Schwartz space:

- Statement (1) ensures the Schwartz space has the nuclear property needed for (3)
- Statement (2) is independent (it concerns complex analysis in finite dimensions)
- Statement (3) applies to the Schwartz space via (1), allowing construction of Gaussian measures from characteristic functionals

The statements are **not contradictory** and in fact work together in the theory of Gaussian measures on nuclear spaces, particularly in quantum field theory and stochastic analysis.

## Notes

The main gap in mathlib4 is the formalization of nuclear spaces and Minlos theorem. The Schwartz space infrastructure and complex analysis theory are well-developed, but the connection to infinite-dimensional probability theory via nuclear spaces remains to be formalized. This would be a significant project requiring:
1. Tensor products of locally convex spaces
2. Projective and injective tensor product topologies
3. Nuclear spaces as those where these coincide
4. Extension of probability theory to nuclear spaces
5. Minlos-Sazonov theorem
### Citations
**File:** Mathlib/Analysis/Distribution/SchwartzSpace.lean (L80-88)
```text
/-- A function is a Schwartz function if it is smooth and all derivatives decay faster than
  any power of `‚Äñx‚Äñ`. -/
structure SchwartzMap where
  /-- The underlying function.

  Do NOT use directly. Use the coercion instead. -/
  toFun : E ‚Üí F
  smooth' : ContDiff ‚Ñù ‚àû toFun
  decay' : ‚àÄ k n : ‚Ñï, ‚àÉ C : ‚Ñù, ‚àÄ x, ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n toFun x‚Äñ ‚â§ C
```
**File:** Mathlib/Analysis/Distribution/SchwartzSpace.lean (L528-529)
```text
instance instLocallyConvexSpace : LocallyConvexSpace ‚Ñù ùì¢(E, F) :=
  (schwartz_withSeminorms ‚Ñù E F).toLocallyConvexSpace
```
**File:** Mathlib/Analysis/Distribution/SchwartzSpace.lean (L531-532)
```text
instance instFirstCountableTopology : FirstCountableTopology ùì¢(E, F) :=
  (schwartz_withSeminorms ‚Ñù E F).firstCountableTopology
```
**File:** Mathlib/Analysis/Complex/CauchyIntegral.lean (L651-653)
```text
protected theorem _root_.Differentiable.analyticAt {f : ‚ÑÇ ‚Üí E} (hf : Differentiable ‚ÑÇ f) (z : ‚ÑÇ) :
    AnalyticAt ‚ÑÇ f z :=
  hf.differentiableOn.analyticAt univ_mem
```
**File:** Mathlib/Analysis/Complex/CauchyIntegral.lean (L669-677)
```text
theorem analyticOnNhd_iff_differentiableOn {f : ‚ÑÇ ‚Üí E} {s : Set ‚ÑÇ} (o : IsOpen s) :
    AnalyticOnNhd ‚ÑÇ f s ‚Üî DifferentiableOn ‚ÑÇ f s :=
  ‚ü®AnalyticOnNhd.differentiableOn, fun d _ zs ‚Ü¶ d.analyticAt (o.mem_nhds zs)‚ü©

/-- On an open set, `f : ‚ÑÇ ‚Üí E` is analytic iff it is differentiable -/
theorem analyticOn_iff_differentiableOn {f : ‚ÑÇ ‚Üí E} {s : Set ‚ÑÇ} (o : IsOpen s) :
    AnalyticOn ‚ÑÇ f s ‚Üî DifferentiableOn ‚ÑÇ f s := by
  rw [o.analyticOn_iff_analyticOnNhd]
  exact analyticOnNhd_iff_differentiableOn o
```
**File:** Mathlib/Analysis/Calculus/FDeriv/Analytic.lean (L126-127)
```text
theorem AnalyticAt.differentiableAt : AnalyticAt ùïú f x ‚Üí DifferentiableAt ùïú f x
  | ‚ü®_, hp‚ü© => hp.differentiableAt
```
**File:** Mathlib/MeasureTheory/Measure/CharacteristicFunction.lean (L1-50)
```text
/-
Copyright (c) 2024 Jakob Stiefel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jakob Stiefel, R√©my Degenne, Thomas Zhu
-/
module

public import Mathlib.Analysis.Fourier.BoundedContinuousFunctionChar
public import Mathlib.Analysis.Fourier.FourierTransform
public import Mathlib.Analysis.InnerProductSpace.Dual
public import Mathlib.Analysis.InnerProductSpace.ProdL2
public import Mathlib.Analysis.Normed.Lp.MeasurableSpace
public import Mathlib.MeasureTheory.Group.IntegralConvolution
public import Mathlib.MeasureTheory.Integral.Pi
public import Mathlib.MeasureTheory.Measure.FiniteMeasureExt

/-!
# Characteristic Function of a Finite Measure

This file defines the characteristic function of a finite measure on a topological vector space `V`.

The characteristic function of a finite measure `P` on `V` is the mapping
`W ‚Üí ‚ÑÇ, w => ‚à´ v, e (L v w) ‚àÇP`,
where `e` is a continuous additive character and `L : V ‚Üí‚Çó[‚Ñù] W ‚Üí‚Çó[‚Ñù] ‚Ñù` is a bilinear map.

A typical example is `V = W = ‚Ñù` and `L v w = v * w`.

The integral is expressed as `‚à´ v, char he hL w v ‚àÇP`, where `char he hL w` is the
bounded continuous function `fun v ‚Ü¶ e (L v w)` and `he`, `hL` are continuity hypotheses on `e`
and `L`.

## Main definitions

* `innerProbChar`: the bounded continuous map `x ‚Ü¶ exp(‚ü™x, t‚ü´ * I)` in an inner product space.
  This is `char` for the inner product bilinear map and the additive character `e = probChar`.
* `charFun Œº t`: the characteristic function of a measure `Œº` at `t` in an inner product space `E`.
  This is defined as `‚à´ x, exp (‚ü™x, t‚ü´ * I) ‚àÇŒº`, where `‚ü™x, t‚ü´` is the inner product on `E`.
  It is equal to `‚à´ v, innerProbChar w v ‚àÇP` (see `charFun_eq_integral_innerProbChar`).
* `probCharDual`: the bounded continuous map `x ‚Ü¶ exp (L x * I)`, for a continuous linear form `L`.
* `charFunDual Œº L`: the characteristic function of a measure `Œº` at `L : Dual ‚Ñù E` in
  a normed space `E`. This is the integral `‚à´ v, exp (L v * I) ‚àÇŒº`.

## Main statements

* `ext_of_integral_char_eq`: Assume `e` and `L` are non-trivial. If the integrals of `char`
  with respect to two finite measures `P` and `P'` coincide, then `P = P'`.
* `Measure.ext_of_charFun`: If the characteristic functions `charFun` of two finite measures
  `Œº` and `ŒΩ` on a complete second-countable inner product space coincide, then `Œº = ŒΩ`.
* `Measure.ext_of_charFunDual`: If the characteristic functions `charFunDual` of two finite measures
  `Œº` and `ŒΩ` on a Banach space coincide, then `Œº = ŒΩ`.
```
**File:** Mathlib/MeasureTheory/Measure/Typeclasses/Probability.lean (L1-50)
```text
/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Mario Carneiro
-/
module

public import Mathlib.MeasureTheory.Measure.Typeclasses.Finite
public import Mathlib.Topology.UnitInterval

/-!
# Classes for probability measures

We introduce the following typeclasses for measures:

* `IsZeroOrProbabilityMeasure Œº`: `Œº univ = 0 ‚à® Œº univ = 1`;
* `IsProbabilityMeasure Œº`: `Œº univ = 1`.
-/

@[expose] public section

namespace MeasureTheory

open Set Measure Filter Function ENNReal

variable {Œ± Œ≤ : Type*} {m0 : MeasurableSpace Œ±} [MeasurableSpace Œ≤] {Œº : Measure Œ±} {s : Set Œ±}

section IsZeroOrProbabilityMeasure

/-- A measure `Œº` is zero or a probability measure if `Œº univ = 0` or `Œº univ = 1`. This class
of measures appears naturally when conditioning on events, and many results which are true for
probability measures hold more generally over this class. -/
class IsZeroOrProbabilityMeasure (Œº : Measure Œ±) : Prop where
  measure_univ : Œº univ = 0 ‚à® Œº univ = 1

lemma isZeroOrProbabilityMeasure_iff : IsZeroOrProbabilityMeasure Œº ‚Üî Œº univ = 0 ‚à® Œº univ = 1 :=
  ‚ü®fun _ ‚Ü¶ IsZeroOrProbabilityMeasure.measure_univ, IsZeroOrProbabilityMeasure.mk‚ü©

lemma prob_le_one {Œº : Measure Œ±} [IsZeroOrProbabilityMeasure Œº] {s : Set Œ±} : Œº s ‚â§ 1 := by
  apply (measure_mono (subset_univ _)).trans
  rcases IsZeroOrProbabilityMeasure.measure_univ (Œº := Œº) with h | h <;> simp [h]

lemma measureReal_le_one {Œº : Measure Œ±} [IsZeroOrProbabilityMeasure Œº] {s : Set Œ±} :
    Œº.real s ‚â§ 1 :=
  ENNReal.toReal_le_of_le_ofReal zero_le_one (ENNReal.ofReal_one.symm ‚ñ∏ prob_le_one)

@[simp]
theorem one_le_prob_iff {Œº : Measure Œ±} [IsZeroOrProbabilityMeasure Œº] : 1 ‚â§ Œº s ‚Üî Œº s = 1 :=
  ‚ü®fun h => le_antisymm prob_le_one h, fun h => h ‚ñ∏ le_refl _‚ü©

```