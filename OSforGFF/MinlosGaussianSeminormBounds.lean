/-
Copyright (c) 2026 Matteo Cipollina. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Matteo Cipollina
-/

import Mathlib.Analysis.LocallyConvex.WithSeminorms
import Mathlib.Analysis.InnerProductSpace.Basic
import Mathlib.Data.Real.Sqrt

/-!
# Seminorm bounds from continuity (Gaussian setup)

If the (squared) covariance seminorm `f ‚Ü¶ ‚ÄñT f‚Äñ¬≤` is continuous and the topology on `E` is
generated by a family of seminorms `p`, then `f ‚Ü¶ ‚ÄñT f‚Äñ` is bounded by a finite supremum of
seminorms from the family.

First step in relating the covariance to a *countable* generating family coming
from nuclearity hypotheses.
-/

open scoped BigOperators ENNReal NNReal

namespace OSforGFF

noncomputable section

namespace MinlosGaussianSeminormBounds

variable {E : Type*} [AddCommGroup E] [Module ‚Ñù E] [TopologicalSpace E]
variable {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ‚Ñù H]

/-- If `f ‚Ü¶ ‚ÄñT f‚Äñ¬≤` is continuous, then `f ‚Ü¶ ‚ÄñT f‚Äñ` is continuous. -/
theorem continuous_norm_of_continuous_norm_sq (T : E ‚Üí‚Çó[‚Ñù] H)
    (h_sq : Continuous fun f : E => (‚ÄñT f‚Äñ ^ 2 : ‚Ñù)) :
    Continuous fun f : E => ‚ÄñT f‚Äñ := by
  have h_sqrt : Continuous fun f : E => Real.sqrt (‚ÄñT f‚Äñ ^ 2 : ‚Ñù) :=
    (Real.continuous_sqrt.comp h_sq)
  simpa [Real.sqrt_sq_eq_abs, abs_of_nonneg (norm_nonneg _)] using h_sqrt

/-- If the topology on `E` is generated by a family of seminorms `p` and `‚ÄñT ¬∑‚Äñ` is continuous,
then it is controlled by finitely many seminorms from the family. -/
theorem seminorm_norm_comp_le_finset_sup
    {Œπ : Type*} (p : Œπ ‚Üí Seminorm ‚Ñù E) (hp : WithSeminorms p)
    (T : E ‚Üí‚Çó[‚Ñù] H)
    (h_sq : Continuous fun f : E => (‚ÄñT f‚Äñ ^ 2 : ‚Ñù)) :
    ‚àÉ s : Finset Œπ, ‚àÉ C : ‚Ñù‚â•0, C ‚â† 0 ‚àß (normSeminorm ‚Ñù H).comp T ‚â§ C ‚Ä¢ s.sup p := by
  have hq : Continuous ((normSeminorm ‚Ñù H).comp T) := by
    have : Continuous fun f : E => ((normSeminorm ‚Ñù H).comp T) f := by
      simpa using (continuous_norm_of_continuous_norm_sq (E := E) (H := H) T h_sq)
    simpa using this
  exact Seminorm.bound_of_continuous (ùïú := ‚Ñù) (p := p) (hp := hp) ((normSeminorm ‚Ñù H).comp T) hq

/-- In the common situation where the generating seminorm family is monotone (e.g. indexed by `‚Ñï`),
the finite supremum bound from `seminorm_norm_comp_le_finset_sup` can be replaced by a bound using
a **single** seminorm from the family. -/
theorem seminorm_norm_comp_le_single_nat
    (p : ‚Ñï ‚Üí Seminorm ‚Ñù E) (hp : WithSeminorms p) (hpmono : Monotone p)
    (T : E ‚Üí‚Çó[‚Ñù] H)
    (h_sq : Continuous fun f : E => (‚ÄñT f‚Äñ ^ 2 : ‚Ñù)) :
    ‚àÉ n : ‚Ñï, ‚àÉ C : ‚Ñù‚â•0, C ‚â† 0 ‚àß (normSeminorm ‚Ñù H).comp T ‚â§ C ‚Ä¢ p n := by
  rcases seminorm_norm_comp_le_finset_sup (E := E) (H := H) (p := p) hp T h_sq with ‚ü®s, C, hC0, hle‚ü©
  classical
  by_cases hs : s.Nonempty
  ¬∑ refine ‚ü®s.max' hs, C, hC0, ?_‚ü©
    -- `s.sup p ‚â§ p (max' s)` by monotonicity.
    have hsup : s.sup p ‚â§ p (s.max' hs) := by
      refine Finset.sup_le ?_
      intro i hi
      exact hpmono (Finset.le_max' _ _ hi)
    -- Multiply the pointwise inequality by `C`.
    have hsupC : C ‚Ä¢ s.sup p ‚â§ C ‚Ä¢ p (s.max' hs) := by
      -- unfold the order on seminorms
      intro x
      have hx := hsup x
      -- scalar multiplication on seminorms is pointwise scalar multiplication on `‚Ñù`
      simpa [Seminorm.smul_apply, NNReal.smul_def, smul_eq_mul, mul_assoc] using
        (mul_le_mul_of_nonneg_left hx (show (0 : ‚Ñù) ‚â§ C by exact_mod_cast C.2))
    exact hle.trans hsupC
  ¬∑ -- If `s = ‚àÖ`, then `s.sup p = ‚ä•`, so the bound is already a single seminorm bound (trivially).
    have hs' : s = ‚àÖ := Finset.not_nonempty_iff_eq_empty.mp hs
    refine ‚ü®0, C, hC0, ?_‚ü©
    -- In this case, `s.sup p = ‚ä•`, so the RHS in `hle` is `C ‚Ä¢ ‚ä• = ‚ä•`.
    -- Hence the desired bound holds because `‚ä• ‚â§ C ‚Ä¢ p 0`.
    have hsup : C ‚Ä¢ s.sup p ‚â§ C ‚Ä¢ p 0 := by
      subst hs'
      intro x
      -- `s.sup p = ‚ä•`, so the LHS is `0`, and the RHS is nonnegative.
      simp [Seminorm.smul_apply, NNReal.smul_def, smul_eq_mul, mul_nonneg]
    exact hle.trans hsup

end MinlosGaussianSeminormBounds

end

end OSforGFF
