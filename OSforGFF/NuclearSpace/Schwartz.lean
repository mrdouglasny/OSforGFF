/-
Copyright (c) 2026 Matteo Cipollina. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Matteo Cipollina
-/

import Mathlib.Analysis.Distribution.SchwartzSpace.Basic
import Mathlib.Analysis.LocallyConvex.WithSeminorms

import OSforGFF.Basic
import OSforGFF.Spacetime.Defs
import OSforGFF.NuclearSpace.Defs
import OSforGFF.NuclearSpace.Std
import OSforGFF.NuclearSpace.Transport

/-!
# Schwartz seminorm sequence and (remaining) nuclearity gap

Mathlib equips the Schwartz space `ùì¢(E, F)` with a locally convex topology generated by the
countable family of seminorms `SchwartzMap.seminorm ùïú k n`, bundled as
`schwartzSeminormFamily ùïú E F : (‚Ñï √ó ‚Ñï) ‚Üí Seminorm ùïú ùì¢(E, F)`.

Our `NuclearSpaceStd` class (used by the Minlos/GFF pipeline) expects a **monotone** family
`p : ‚Ñï ‚Üí Seminorm ‚Ñù E`. In this file we build such a family canonically for
`TestFunction = ùì¢(SpaceTime, ‚Ñù)` by taking finite sups along the diagonal:

`p n = sup_{(k,m) ‚â§ (n,n)} schwartzSeminormFamily (k,m)`.

We prove:
- `Monotone schwartzSeminormSeq`;
- `WithSeminorms schwartzSeminormSeq`, i.e. it generates the existing Schwartz topology.

The **only** remaining (deep) ingredient needed to derive `NuclearSpaceStd TestFunction` is the
nuclearity of the local Banach inclusions for this specific seminorm sequence. We isolate this as
`SchwartzNuclearInclusion`.

In this repository, the spacetime Hermite development discharges this hypothesis: see
`OSforGFF.NuclearSpace.PhysHermiteSpaceTimeSchwartzNuclearInclusion` for a canonical instance.
-/

open scoped BigOperators

namespace OSforGFF

noncomputable section

open TopologicalSpace

/-! ## Generic Schwartz seminorm sequence on `ùì¢(E, ‚Ñù)` -/

namespace SchwartzSeq

variable {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]

/-- The underlying Schwartz seminorm family on `ùì¢(E, ‚Ñù)`, indexed by `‚Ñï √ó ‚Ñï`. -/
abbrev schwartzSeminormFamily (E : Type*) [NormedAddCommGroup E] [NormedSpace ‚Ñù E] :
    (‚Ñï √ó ‚Ñï) ‚Üí Seminorm ‚Ñù (SchwartzMap E ‚Ñù) :=
  _root_.schwartzSeminormFamily ‚Ñù E ‚Ñù

/-- A monotone `‚Ñï`-indexed seminorm family generating the Schwartz topology on `ùì¢(E, ‚Ñù)`, obtained by
taking finite sups over `Finset.Iic (n,n)`. -/
noncomputable def schwartzSeminormSeq (E : Type*) [NormedAddCommGroup E] [NormedSpace ‚Ñù E] (n : ‚Ñï) :
    Seminorm ‚Ñù (SchwartzMap E ‚Ñù) :=
  (Finset.Iic (n, n)).sup (schwartzSeminormFamily (E := E))

theorem schwartzSeminormSeq_mono : Monotone (schwartzSeminormSeq (E := E)) := by
  intro a b hab
  have hsubset : Finset.Iic (a, a) ‚äÜ Finset.Iic (b, b) := by
    intro x hx
    have hxle : x ‚â§ (a, a) := Finset.mem_Iic.mp hx
    have hab' : (a, a) ‚â§ (b, b) := Prod.mk_le_mk.2 ‚ü®hab, hab‚ü©
    exact Finset.mem_Iic.mpr (le_trans hxle hab')
  exact Finset.sup_mono hsubset

theorem schwartzSeminormSeq_withSeminorms : WithSeminorms (schwartzSeminormSeq (E := E)) := by
  -- Start from Mathlib's `WithSeminorms` for the `(‚Ñï √ó ‚Ñï)`-indexed Schwartz family.
  let q : (‚Ñï √ó ‚Ñï) ‚Üí Seminorm ‚Ñù (SchwartzMap E ‚Ñù) := schwartzSeminormFamily (E := E)
  have hq : WithSeminorms q := by
    simpa [q, schwartzSeminormFamily] using
      (schwartz_withSeminorms (ùïú := ‚Ñù) (E := E) (F := ‚Ñù))
  -- Replace `q` by its `Finset.Iic` partial sups. This does not change the topology.
  let q' : (‚Ñï √ó ‚Ñï) ‚Üí Seminorm ‚Ñù (SchwartzMap E ‚Ñù) := fun i => (Finset.Iic i).sup q
  have hq' : WithSeminorms q' := WithSeminorms.partial_sups (hp := hq)
  -- Restrict to the diagonal `n ‚Ü¶ q' (n,n)`; this is cofinal, hence generates the same topology.
  let p : ‚Ñï ‚Üí Seminorm ‚Ñù (SchwartzMap E ‚Ñù) := fun n => q' (n, n)
  have hpq' : Seminorm.IsBounded q' p LinearMap.id := by
    intro n
    refine ‚ü®{(n, n)}, 1, ?_‚ü©
    simp [p, one_smul]
  have hq'p : Seminorm.IsBounded p q' LinearMap.id := by
    intro i
    refine ‚ü®{Nat.max i.1 i.2}, 1, ?_‚ü©
    have hle : q' i ‚â§ p (Nat.max i.1 i.2) := by
      have hi : i ‚â§ (Nat.max i.1 i.2, Nat.max i.1 i.2) :=
        Prod.mk_le_mk.2 ‚ü®le_max_left _ _, le_max_right _ _‚ü©
      have hsubset : Finset.Iic i ‚äÜ Finset.Iic (Nat.max i.1 i.2, Nat.max i.1 i.2) := by
        intro x hx
        exact Finset.mem_Iic.mpr (le_trans (Finset.mem_Iic.mp hx) hi)
      simpa [q', p] using (Finset.sup_mono hsubset)
    simpa [Seminorm.comp_apply, p, one_smul] using hle
  simpa [schwartzSeminormSeq, p, q'] using
    (WithSeminorms.congr (p := q') (q := p) (hp := hq') (hpq := hpq') (hqp := hq'p)
      : WithSeminorms p)

end SchwartzSeq

/-! ## A canonical monotone `‚Ñï`-family generating the Schwartz topology -/

/-- The underlying Schwartz seminorm family on `TestFunction`, indexed by `‚Ñï √ó ‚Ñï`. -/
abbrev schwartzSeminormFamily_TestFunction : (‚Ñï √ó ‚Ñï) ‚Üí Seminorm ‚Ñù TestFunction :=
  SchwartzSeq.schwartzSeminormFamily (E := SpaceTime)

/-- A monotone `‚Ñï`-indexed seminorm family generating the Schwartz topology, obtained by taking
finite sups over `Finset.Iic (n,n)`. -/
noncomputable def schwartzSeminormSeq (n : ‚Ñï) : Seminorm ‚Ñù TestFunction :=
  SchwartzSeq.schwartzSeminormSeq (E := SpaceTime) n

theorem schwartzSeminormSeq_mono : Monotone schwartzSeminormSeq := by
  simpa [schwartzSeminormSeq] using (SchwartzSeq.schwartzSeminormSeq_mono (E := SpaceTime))

theorem schwartzSeminormSeq_withSeminorms : WithSeminorms schwartzSeminormSeq := by
  simpa [schwartzSeminormSeq] using
    (SchwartzSeq.schwartzSeminormSeq_withSeminorms (E := SpaceTime))

/-! ## The remaining nuclearity assumption, in canonical Schwartz terms -/

open OSforGFF

/-- The **remaining** (deep) nuclearity step for the Schwartz space: for the canonical seminorm
sequence `schwartzSeminormSeq`, the local Banach inclusions are nuclear.

Assuming this, we get `NuclearSpaceStd TestFunction` without any `Classical.choose`
in the *choice of seminorm family* (only in the nuclearity proofs, if provided). -/
def SchwartzNuclearInclusion : Prop :=
  ‚àÄ n : ‚Ñï, ‚àÉ m : ‚Ñï, ‚àÉ hnm : n < m,
    IsNuclearMap
      (BanachOfSeminorm.inclCLM (E := TestFunction)
        (p := schwartzSeminormSeq m)
        (q := schwartzSeminormSeq n)
        (by
          have hm := schwartzSeminormSeq_mono (a := n) (b := m) (Nat.le_of_lt hnm)
          exact hm))

/-- If `schwartzSeminormSeq` is equivalent (via `Seminorm.IsBounded ‚Ä¶ LinearMap.id`) to some other
monotone seminorm sequence with nuclear local inclusions, then the canonical
`SchwartzNuclearInclusion` hypothesis holds. -/
theorem schwartzNuclearInclusion_of_equivFamily
    {q : ‚Ñï ‚Üí Seminorm ‚Ñù TestFunction} (hqmono : Monotone q)
    (hb_q_le_sch : Seminorm.IsBounded schwartzSeminormSeq q (LinearMap.id : TestFunction ‚Üí‚Çó[‚Ñù] TestFunction))
    (hb_sch_le_q : Seminorm.IsBounded q schwartzSeminormSeq (LinearMap.id : TestFunction ‚Üí‚Çó[‚Ñù] TestFunction))
    (hqNuclear : ‚àÄ n : ‚Ñï, ‚àÉ m : ‚Ñï, ‚àÉ hnm : n < m,
      IsNuclearMap
        (BanachOfSeminorm.inclCLM (E := TestFunction) (p := q m) (q := q n)
          (hqmono (Nat.le_of_lt hnm)))) :
    SchwartzNuclearInclusion := by
  intro n
  rcases
      (NuclearSpaceStd.isNuclear_inclCLM_of_isBounded (E := TestFunction)
        (p := schwartzSeminormSeq) (q := q)
        schwartzSeminormSeq_mono hqmono hb_q_le_sch hb_sch_le_q hqNuclear n)
    with ‚ü®m, hnm, hNuc‚ü©
  refine ‚ü®m, hnm, ?_‚ü©
  simpa using hNuc

/-- A more canonical variant: if `q` is a monotone seminorm sequence that generates the Schwartz
topology (`WithSeminorms q`) and has nuclear local inclusions, then the canonical
`SchwartzNuclearInclusion` holds. -/
theorem schwartzNuclearInclusion_of_withSeminorms
    {q : ‚Ñï ‚Üí Seminorm ‚Ñù TestFunction} (hqmono : Monotone q) (hq : WithSeminorms q)
    (hqNuclear : ‚àÄ n : ‚Ñï, ‚àÉ m : ‚Ñï, ‚àÉ hnm : n < m,
      IsNuclearMap
        (BanachOfSeminorm.inclCLM (E := TestFunction) (p := q m) (q := q n)
          (hqmono (Nat.le_of_lt hnm)))) :
    SchwartzNuclearInclusion := by
  have hb_q_le_sch :
      Seminorm.IsBounded schwartzSeminormSeq q (LinearMap.id : TestFunction ‚Üí‚Çó[‚Ñù] TestFunction) :=
    WithSeminorms.isBounded_id (p := schwartzSeminormSeq) (q := q)
      schwartzSeminormSeq_withSeminorms hq
  have hb_sch_le_q :
      Seminorm.IsBounded q schwartzSeminormSeq (LinearMap.id : TestFunction ‚Üí‚Çó[‚Ñù] TestFunction) :=
    WithSeminorms.isBounded_id (p := q) (q := schwartzSeminormSeq)
      hq schwartzSeminormSeq_withSeminorms
  exact schwartzNuclearInclusion_of_equivFamily (q := q) hqmono hb_q_le_sch hb_sch_le_q hqNuclear

/-- If the canonical Schwartz nuclear-inclusion hypothesis holds, then `TestFunction` is a
`NuclearSpaceStd` in the sense used by the Minlos/GFF pipeline. -/
theorem nuclearSpaceStd_TestFunction_of_schwartzNuclearInclusion
    (hSch : SchwartzNuclearInclusion) : NuclearSpaceStd TestFunction := by
  refine ‚ü®?_‚ü©
  refine ‚ü®schwartzSeminormSeq, schwartzSeminormSeq_mono, schwartzSeminormSeq_withSeminorms, ?_‚ü©
  intro n
  rcases hSch n with ‚ü®m, hnm, hNuc‚ü©
  refine ‚ü®m, hnm, ?_‚ü©
  simpa using hNuc

end
end OSforGFF
