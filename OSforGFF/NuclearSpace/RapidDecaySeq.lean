/-
Copyright (c) 2026 Matteo Cipollina. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Matteo Cipollina
-/

import Mathlib.Analysis.InnerProductSpace.l2Space
import Mathlib.Analysis.PSeries

import OSforGFF.NuclearSpace.Defs
import OSforGFF.NuclearSpace.Std

/-!
# A model nuclear Fr√©chet space: rapidly decreasing sequences

This file develops a **fully proved** model example of a `NuclearSpaceStd` in the sense used by the
Minlos/GFF pipeline: the space `RapidDecaySeq` of rapidly decreasing real sequences, endowed with
the Fr√©chet topology generated by weighted `‚Ñì¬≤` seminorms.

The point is not to *assume* Schwartz nuclearity, but to build a solid, axiom-free nucleus that can
later be related to `TestFunction` once an explicit topological isomorphism (e.g. via Hermite
expansions) is available.
-/

open scoped BigOperators NNReal ENNReal

namespace OSforGFF

noncomputable section

/-! ## The space of rapidly decreasing sequences -/

local notation "H" => ‚Ñì¬≤(‚Ñï, ‚Ñù)

/-- The weight \(w_k(n) = (n+1)^k\). -/
def weight (k : ‚Ñï) (n : ‚Ñï) : ‚Ñù := ((n + 1 : ‚Ñù) ^ k)

/-- Pointwise weighting of a sequence by `weight k`. -/
def weightFun (k : ‚Ñï) (f : ‚Ñï ‚Üí ‚Ñù) : ‚Ñï ‚Üí ‚Ñù := fun n => weight k n * f n

@[simp]
lemma weight_zero (n : ‚Ñï) : weight 0 n = 1 := by
  simp [weight]

@[simp]
lemma weight_succ (k n : ‚Ñï) : weight (k + 1) n = weight k n * (n + 1) := by
  simp [weight, pow_succ]

/-- The submodule of sequences whose weighted versions are in `‚Ñì¬≤` for every weight. -/
def RapidDecaySeq : Submodule ‚Ñù (‚Ñï ‚Üí ‚Ñù) where
  carrier := { f | ‚àÄ k : ‚Ñï, Mem‚Ñìp (weightFun k f) (2 : ‚Ñù‚â•0‚àû) }
  zero_mem' := by
    intro k
    have h0 : weightFun k (0 : ‚Ñï ‚Üí ‚Ñù) = 0 := by
      funext n
      simp [weightFun]
    simpa [h0] using (zero_mem‚Ñìp (E := fun _ : ‚Ñï => ‚Ñù) (p := (2 : ‚Ñù‚â•0‚àû)))
  add_mem' := by
    intro f g hf hg k
    have hfg : weightFun k (f + g) = weightFun k f + weightFun k g := by
      funext n
      simp [weightFun, mul_add]
    simpa [hfg] using (hf k).add (hg k)
  smul_mem' := by
    intro c f hf k
    have hsmul : weightFun k (c ‚Ä¢ f) = c ‚Ä¢ weightFun k f := by
      funext n
      simp [weightFun, mul_assoc, mul_comm]
    simpa [hsmul] using (hf k).const_smul c

/-! We use `RapidDecaySeq` as a **type** via the coercion `Submodule ‚Üí Sort`. -/

namespace RapidDecaySeq

variable (k : ‚Ñï)

/-- The canonical map to `‚Ñì¬≤`: send a rapidly decreasing sequence to its `k`-weighted version. -/
noncomputable def toL2‚Çó : RapidDecaySeq ‚Üí‚Çó[‚Ñù] H where
  toFun x := ‚ü®weightFun k x.1, x.2 k‚ü©
  map_add' x y := by
    ext n
    simp [weightFun, mul_add]
  map_smul' c x := by
    ext n
    simp [weightFun, mul_left_comm]

@[simp]
lemma toL2‚Çó_apply (x : RapidDecaySeq) (n : ‚Ñï) :
    (toL2‚Çó k x : ‚Ñï ‚Üí ‚Ñù) n = weight k n * x.1 n := rfl

/-- The weighted `‚Ñì¬≤` seminorms generating the Fr√©chet topology. -/
noncomputable def seminorm : Seminorm ‚Ñù RapidDecaySeq :=
  (normSeminorm ‚Ñù H).comp (toL2‚Çó k)

@[simp]
lemma seminorm_apply (x : RapidDecaySeq) :
    seminorm k x = ‚ÄñtoL2‚Çó k x‚Äñ := by
  rfl

theorem seminorm_mono : Monotone (fun k : ‚Ñï => seminorm k) := by
  intro a b hab x
  -- Compare the norms of the two weighted sequences pointwise.
  have hp : (0 : ‚Ñù) < ((2 : ‚Ñù‚â•0‚àû).toReal) := by norm_num
  let A : H := toL2‚Çó a x
  let B : H := toL2‚Çó b x
  have hAB :
      ‚ÄñA‚Äñ ‚â§ ‚ÄñB‚Äñ := by
    refine lp.norm_le_of_forall_sum_le (p := (2 : ‚Ñù‚â•0‚àû)) hp (C := ‚ÄñB‚Äñ) (by positivity) ?_
    intro s
    have hpoint : ‚àÄ n, ‚ÄñA n‚Äñ ^ ((2 : ‚Ñù‚â•0‚àû).toReal) ‚â§ ‚ÄñB n‚Äñ ^ ((2 : ‚Ñù‚â•0‚àû).toReal) := by
      intro n
      have hle_w : weight a n ‚â§ weight b n := by
        have h1 : (1 : ‚Ñù) ‚â§ (n + 1 : ‚Ñù) := by
          exact_mod_cast (Nat.succ_le_succ (Nat.zero_le n))
        simpa [weight] using (pow_le_pow_right‚ÇÄ h1 hab)
      have hn : 0 ‚â§ weight a n := by
        have : 0 ‚â§ (n + 1 : ‚Ñù) := by positivity
        simpa [weight] using pow_nonneg this a
      have hn' : 0 ‚â§ weight b n := by
        have : 0 ‚â§ (n + 1 : ‚Ñù) := by positivity
        simpa [weight] using pow_nonneg this b
      have habs :
          ‚Äñ(weight a n * x.1 n)‚Äñ ‚â§ ‚Äñ(weight b n * x.1 n)‚Äñ := by
        simpa [Real.norm_eq_abs, abs_mul, abs_of_nonneg hn, abs_of_nonneg hn'] using
          mul_le_mul_of_nonneg_right hle_w (abs_nonneg (x.1 n))
      have : (‚Äñweight a n * x.1 n‚Äñ) ^ ((2 : ‚Ñù‚â•0‚àû).toReal)
            ‚â§ (‚Äñweight b n * x.1 n‚Äñ) ^ ((2 : ‚Ñù‚â•0‚àû).toReal) := by
        exact Real.rpow_le_rpow (norm_nonneg _) habs (by norm_num)
      simpa [A, B, toL2‚Çó_apply] using this
    calc
      ‚àë i ‚àà s, ‚ÄñA i‚Äñ ^ ((2 : ‚Ñù‚â•0‚àû).toReal)
          ‚â§ ‚àë i ‚àà s, ‚ÄñB i‚Äñ ^ ((2 : ‚Ñù‚â•0‚àû).toReal) := by
              exact Finset.sum_le_sum fun i hi => hpoint i
      _ ‚â§ ‚ÄñB‚Äñ ^ ((2 : ‚Ñù‚â•0‚àû).toReal) := by
            simpa using (lp.sum_rpow_le_norm_rpow (p := (2 : ‚Ñù‚â•0‚àû)) hp B s)
  simpa [seminorm, A, B] using hAB

/-! ## Topology generated by the seminorms -/

noncomputable instance (priority := 2000) : TopologicalSpace RapidDecaySeq :=
  (SeminormFamily.moduleFilterBasis (ùïú := ‚Ñù) (F := RapidDecaySeq) (p := fun k => seminorm k)).topology

theorem withSeminorms : WithSeminorms (fun k : ‚Ñï => seminorm k) := by
  -- We *define* the topology to be the one induced by these seminorms.
  exact ‚ü®rfl‚ü©

/-! ## A diagonal nuclear operator on `‚Ñì¬≤` -/

/-- Coefficients \(\sigma_s(n) = (n+1)^{-s}\). -/
def sigma (s : ‚Ñï) (n : ‚Ñï) : ‚Ñù := ((weight s n)‚Åª¬π)

@[simp]
lemma sigma_apply (s n : ‚Ñï) : sigma s n = (weight s n)‚Åª¬π := rfl

lemma abs_sigma_le_one (s n : ‚Ñï) : |sigma s n| ‚â§ 1 := by
  have hpos : 0 < weight s n := by
    have : 0 < (n + 1 : ‚Ñù) := by exact_mod_cast (Nat.succ_pos n)
    simpa [weight] using (pow_pos this s)
  have hone : (1 : ‚Ñù) ‚â§ weight s n := by
    have h1 : (1 : ‚Ñù) ‚â§ (n + 1 : ‚Ñù) := by
      exact_mod_cast (Nat.succ_le_succ (Nat.zero_le n))
    simpa [weight] using (one_le_pow‚ÇÄ (a := (n + 1 : ‚Ñù)) h1 (n := s))
  have : (weight s n)‚Åª¬π ‚â§ 1 := by
    simpa [one_div] using (inv_le_one_of_one_le‚ÇÄ hone)
  simpa [sigma, abs_of_pos (inv_pos_of_pos hpos)] using this

/-- The diagonal linear map on `‚Ñì¬≤` given by multiplying coordinates by `sigma s`. -/
noncomputable def diagPowInv‚Çó (s : ‚Ñï) : H ‚Üí‚Çó[‚Ñù] H where
  toFun x :=
    ‚ü®fun n => sigma s n * x n, by
      have hp : (0 : ‚Ñù) < ((2 : ‚Ñù‚â•0‚àû).toReal) := by norm_num
      have hx : Summable (fun n : ‚Ñï => ‚Äñx n‚Äñ ^ ((2 : ‚Ñù‚â•0‚àû).toReal)) :=
        (lp.mem‚Ñìp x).summable hp
      have hnonneg : ‚àÄ n : ‚Ñï, 0 ‚â§ ‚Äñsigma s n * x n‚Äñ ^ ((2 : ‚Ñù‚â•0‚àû).toReal) := by
        intro n; positivity
      have hle : ‚àÄ n : ‚Ñï, ‚Äñsigma s n * x n‚Äñ ^ ((2 : ‚Ñù‚â•0‚àû).toReal) ‚â§ ‚Äñx n‚Äñ ^ ((2 : ‚Ñù‚â•0‚àû).toReal) := by
        intro n
        have : ‚Äñsigma s n * x n‚Äñ ‚â§ ‚Äñx n‚Äñ := by
          have hs : ‚Äñsigma s n‚Äñ ‚â§ 1 := by
            simpa [Real.norm_eq_abs] using abs_sigma_le_one (s := s) (n := n)
          calc
            ‚Äñsigma s n * x n‚Äñ = ‚Äñsigma s n‚Äñ * ‚Äñx n‚Äñ := by simp [norm_mul]
            _ ‚â§ 1 * ‚Äñx n‚Äñ := by gcongr
            _ = ‚Äñx n‚Äñ := by simp
        exact Real.rpow_le_rpow (norm_nonneg _) this (by norm_num)
      refine mem‚Ñìp_gen (p := (2 : ‚Ñù‚â•0‚àû)) ?_
      exact Summable.of_nonneg_of_le hnonneg hle hx‚ü©
  map_add' x y := by
    ext n
    change sigma s n * (x n + y n) = sigma s n * x n + sigma s n * y n
    simp [mul_add]
  map_smul' c x := by
    ext n
    simp [mul_left_comm]

@[simp]
lemma diagPowInv‚Çó_apply (s : ‚Ñï) (x : H) (n : ‚Ñï) :
  (diagPowInv‚Çó s x : ‚Ñï ‚Üí ‚Ñù) n = sigma s n * x n := rfl

/-- The diagonal continuous linear map on `‚Ñì¬≤` given by multiplying coordinates by `sigma s`. -/
noncomputable def diagPowInvCLM (s : ‚Ñï) : H ‚ÜíL[‚Ñù] H := by
  refine (diagPowInv‚Çó s).mkContinuous 1 ?_
  intro x
  have hp : (0 : ‚Ñù) < ((2 : ‚Ñù‚â•0‚àû).toReal) := by norm_num
  let y : H := diagPowInv‚Çó s x
  have hy : ‚Äñy‚Äñ ‚â§ ‚Äñx‚Äñ := by
    refine lp.norm_le_of_forall_sum_le (p := (2 : ‚Ñù‚â•0‚àû)) hp (C := ‚Äñx‚Äñ) (by positivity) ?_
    intro t
    have hle_term : ‚àÄ n : ‚Ñï, ‚Äñy n‚Äñ ^ ((2 : ‚Ñù‚â•0‚àû).toReal) ‚â§ ‚Äñx n‚Äñ ^ ((2 : ‚Ñù‚â•0‚àû).toReal) := by
      intro n
      have : ‚Äñy n‚Äñ ‚â§ ‚Äñx n‚Äñ := by
        have hs' : ‚Äñsigma s n‚Äñ ‚â§ 1 := by
          simpa [Real.norm_eq_abs] using abs_sigma_le_one (s := s) (n := n)
        calc
          ‚Äñy n‚Äñ = ‚Äñsigma s n * x n‚Äñ := by simp [y, diagPowInv‚Çó_apply]
          _ = ‚Äñsigma s n‚Äñ * ‚Äñx n‚Äñ := by simp [norm_mul]
          _ ‚â§ 1 * ‚Äñx n‚Äñ := by gcongr
          _ = ‚Äñx n‚Äñ := by simp
      exact Real.rpow_le_rpow (norm_nonneg _) this (by norm_num)
    calc
      ‚àë i ‚àà t, ‚Äñy i‚Äñ ^ ((2 : ‚Ñù‚â•0‚àû).toReal)
          ‚â§ ‚àë i ‚àà t, ‚Äñx i‚Äñ ^ ((2 : ‚Ñù‚â•0‚àû).toReal) := by
              exact Finset.sum_le_sum fun i hi => hle_term i
      _ ‚â§ ‚Äñx‚Äñ ^ ((2 : ‚Ñù‚â•0‚àû).toReal) := by
            simpa using (lp.sum_rpow_le_norm_rpow (p := (2 : ‚Ñù‚â•0‚àû)) hp x t)
  simpa [y] using (hy.trans_eq (by simp))

@[simp]
lemma diagPowInvCLM_apply (s : ‚Ñï) (x : H) (n : ‚Ñï) :
  (diagPowInvCLM s x : ‚Ñï ‚Üí ‚Ñù) n = sigma s n * x n := rfl

/-! ### Nuclearity of the diagonal map for `s > 1` -/

theorem summable_sigma_norm (s : ‚Ñï) (hs : 1 < s) :
    Summable (fun n : ‚Ñï => ‚Äñsigma s n‚Äñ) := by
  have h : Summable (fun n : ‚Ñï => ((n : ‚Ñù) ^ s)‚Åª¬π) := by
    exact (Real.summable_nat_pow_inv (p := s)).2 hs
  have h' : Summable (fun n : ‚Ñï => ((n + 1 : ‚Ñù) ^ s)‚Åª¬π) := by
    have h‚ÇÅ : Summable (fun n : ‚Ñï => (((n + 1 : ‚Ñï) : ‚Ñù) ^ s)‚Åª¬π) := by
      simpa using ((_root_.summable_nat_add_iff (f := fun n : ‚Ñï => ((n : ‚Ñù) ^ s)‚Åª¬π) 1).2 h)
    simpa [Nat.cast_add_one] using h‚ÇÅ
  have hnorm : (fun n : ‚Ñï => ‚Äñsigma s n‚Äñ) = fun n : ‚Ñï => ((n + 1 : ‚Ñù) ^ s)‚Åª¬π := by
    funext n
    have hpos : 0 < weight s n := by
      have : 0 < (n + 1 : ‚Ñù) := by exact_mod_cast (Nat.succ_pos n)
      simpa [weight] using (pow_pos this s)
    have hposInv : 0 < (weight s n)‚Åª¬π := inv_pos_of_pos hpos
    have : ‚Äñsigma s n‚Äñ = (weight s n)‚Åª¬π := by
      calc
        ‚Äñsigma s n‚Äñ = |sigma s n| := by simp [Real.norm_eq_abs]
        _ = |(weight s n)‚Åª¬π| := by simp [sigma]
        _ = (weight s n)‚Åª¬π := abs_of_pos hposInv
    simpa [weight] using this
  rw [hnorm]
  exact h'

theorem isNuclearMap_diagPowInvCLM (s : ‚Ñï) (hs : 1 < s) :
    IsNuclearMap (diagPowInvCLM s) := by
  classical
  -- Orthonormal coordinate vectors in `‚Ñì¬≤`.
  haveI : Fact ((1 : ‚Ñù‚â•0‚àû) ‚â§ (2 : ‚Ñù‚â•0‚àû)) := ‚ü®by norm_num‚ü©
  let e : ‚Ñï ‚Üí H := fun n => lp.single (E := fun _ : ‚Ñï => ‚Ñù) 2 n (1 : ‚Ñù)
  let œÜ : ‚Ñï ‚Üí (H ‚ÜíL[‚Ñù] ‚Ñù) := fun n => innerSL ‚Ñù (e n)
  let y : ‚Ñï ‚Üí H := fun n => (sigma s n) ‚Ä¢ e n
  refine ‚ü®œÜ, y, ?_, ?_‚ü©
  ¬∑ have hœÜ : ‚àÄ n, ‚ÄñœÜ n‚Äñ = 1 := by
      intro n
      have : ‚Äñe n‚Äñ = 1 := by
        simp [e]
      simp [œÜ, this]
    have hy : ‚àÄ n, ‚Äñy n‚Äñ = ‚Äñsigma s n‚Äñ := by
      intro n
      have : ‚Äñe n‚Äñ = 1 := by
        simp [e]
      simpa [y, this, norm_smul] using (by rfl : ‚Äñ(sigma s n) ‚Ä¢ e n‚Äñ = ‚Äñsigma s n‚Äñ * ‚Äñe n‚Äñ)
    have hsum : Summable (fun n : ‚Ñï => ‚Äñsigma s n‚Äñ) := summable_sigma_norm (s := s) hs
    refine (hsum.congr ?_)
    intro n
    simp [hœÜ n, hy n]
  ¬∑ intro x
    have hx : HasSum (fun n : ‚Ñï => lp.single 2 n ((diagPowInvCLM s x) n)) (diagPowInvCLM s x) :=
      lp.hasSum_single (E := fun _ : ‚Ñï => ‚Ñù) (p := (2 : ‚Ñù‚â•0‚àû)) ENNReal.ofNat_ne_top (diagPowInvCLM s x)
    have hterm : ‚àÄ n : ‚Ñï, lp.single 2 n ((diagPowInvCLM s x) n) = (œÜ n x) ‚Ä¢ y n := by
      intro n
      have hœÜx : œÜ n x = x n := by
        simpa [œÜ, e, innerSL_apply_apply] using
          (lp.inner_single_left (ùïú := ‚Ñù) (Œπ := ‚Ñï) (G := fun _ : ‚Ñï => ‚Ñù) n (1 : ‚Ñù) x)
      have hs' :
          lp.single (E := fun _ : ‚Ñï => ‚Ñù) (2 : ‚Ñù‚â•0‚àû) n ((weight s n)‚Åª¬π * x n) =
            ((weight s n)‚Åª¬π * x n) ‚Ä¢ lp.single (E := fun _ : ‚Ñï => ‚Ñù) (2 : ‚Ñù‚â•0‚àû) n (1 : ‚Ñù) := by
        simpa using
          (lp.single_smul (E := fun _ : ‚Ñï => ‚Ñù) (p := (2 : ‚Ñù‚â•0‚àû)) n ((weight s n)‚Åª¬π * x n) (1 : ‚Ñù))
      simp [y, e, diagPowInvCLM_apply, hœÜx, hs', sigma, smul_smul,
        mul_comm]
    have hx' : HasSum (fun n : ‚Ñï => (œÜ n x) ‚Ä¢ y n) (diagPowInvCLM s x) :=
      HasSum.congr_fun hx (fun n => (hterm n).symm)
    exact hx'.tsum_eq.symm

/-!
## `RapidDecaySeq` is a standard nuclear Fr√©chet space

We now discharge the promise from the module header: the Fr√©chet space `RapidDecaySeq` (rapidly
decreasing sequences with `‚Ñì¬≤`-weighted seminorms) is an instance of `NuclearSpaceStd`.

Idea:
- The local Banach space associated to the seminorm `seminorm k` identifies isometrically with `‚Ñì¬≤`
  via the dense map `x ‚Ü¶ weightFun k x`.
- Under this identification, the canonical inclusion from level `k+2` to level `k` becomes the
  diagonal map `diagPowInvCLM 2`, which is nuclear by `isNuclearMap_diagPowInvCLM`.
-/

open scoped Topology

-- NOTE: `RapidDecaySeq` already carries a Fr√©chet topology, so the quotient type
-- `QuotBySeminorm (seminorm k)` would also inherit a quotient topology.  For the Banach/completion
-- constructions in `OSforGFF.NuclearSpace.Defs`, we instead want the topology induced by the
-- quotient *norm*.
local instance (priority := 1001) (k : ‚Ñï) :
    TopologicalSpace (QuotBySeminorm (E := RapidDecaySeq) (seminorm k)) :=
  (PseudoMetricSpace.toUniformSpace.toTopologicalSpace :
    TopologicalSpace (QuotBySeminorm (E := RapidDecaySeq) (seminorm k)))

/-! ### The quotient-level map into `‚Ñì¬≤` -/

-- The quotient by `seminormKer (seminorm k)` maps linearly to `‚Ñì¬≤` by applying `toL2‚Çó k` to
-- representatives; this is well-defined since `seminorm k x = ‚ÄñtoL2‚Çó k x‚Äñ`.
noncomputable def toL2Quot‚Çó (k : ‚Ñï) :
    QuotBySeminorm (E := RapidDecaySeq) (seminorm k) ‚Üí‚Çó[‚Ñù] H :=
  (seminormKer (E := RapidDecaySeq) (p := seminorm k)).liftQ (toL2‚Çó k) (by
    intro x hx
    have hx0 : seminorm k x = 0 := hx
    have : ‚ÄñtoL2‚Çó k x‚Äñ = 0 := by
      simpa [seminorm_apply] using hx0
    exact (norm_eq_zero.mp this))

@[simp] lemma toL2Quot‚Çó_mk (k : ‚Ñï) (x : RapidDecaySeq) :
    toL2Quot‚Çó k (Submodule.Quotient.mk (p := seminormKer (E := RapidDecaySeq) (p := seminorm k)) x) =
      toL2‚Çó k x := by
  simp [toL2Quot‚Çó]

lemma norm_toL2Quot‚Çó (k : ‚Ñï) (x : QuotBySeminorm (E := RapidDecaySeq) (seminorm k)) :
    ‚ÄñtoL2Quot‚Çó k x‚Äñ = ‚Äñx‚Äñ := by
  refine Submodule.Quotient.induction_on (p := seminormKer (E := RapidDecaySeq) (p := seminorm k)) x ?_
  intro y
  have hy_norm :
      ‚Äñ(Submodule.Quotient.mk (p := seminormKer (E := RapidDecaySeq) (p := seminorm k)) y :
          QuotBySeminorm (E := RapidDecaySeq) (seminorm k))‚Äñ = seminorm k y := by
    simpa using (QuotBySeminorm.norm_mk (E := RapidDecaySeq) (p := seminorm k) y)
  calc
    ‚ÄñtoL2Quot‚Çó k (Submodule.Quotient.mk (p := seminormKer (E := RapidDecaySeq) (p := seminorm k)) y)‚Äñ
        = ‚ÄñtoL2‚Çó k y‚Äñ := by simp [toL2Quot‚Çó_mk]
    _ = seminorm k y := by simp [seminorm_apply]
    _ = ‚Äñ(Submodule.Quotient.mk (p := seminormKer (E := RapidDecaySeq) (p := seminorm k)) y :
            QuotBySeminorm (E := RapidDecaySeq) (seminorm k))‚Äñ := by simp [hy_norm]

lemma denseRange_toL2‚Çó (k : ‚Ñï) : DenseRange (toL2‚Çó k) := by
  classical
  intro y
  haveI : Fact ((1 : ‚Ñù‚â•0‚àû) ‚â§ (2 : ‚Ñù‚â•0‚àû)) := ‚ü®by norm_num‚ü©
  have hy_hasSum :
      HasSum (fun n : ‚Ñï => lp.single (E := fun _ : ‚Ñï => ‚Ñù) (2 : ‚Ñù‚â•0‚àû) n (y n)) y :=
    lp.hasSum_single (E := fun _ : ‚Ñï => ‚Ñù) (p := (2 : ‚Ñù‚â•0‚àû)) ENNReal.ofNat_ne_top y
  have hy_tendsto :
      Filter.Tendsto
        (fun N : ‚Ñï =>
          ‚àë n ‚àà Finset.range N,
            lp.single (E := fun _ : ‚Ñï => ‚Ñù) (2 : ‚Ñù‚â•0‚àû) n (y n))
        Filter.atTop (nhds y) :=
    hy_hasSum.tendsto_sum_nat
  have h_mem_range :
      ‚àÄ N : ‚Ñï,
        (‚àë n ‚àà Finset.range N, lp.single (E := fun _ : ‚Ñï => ‚Ñù) (2 : ‚Ñù‚â•0‚àû) n (y n))
          ‚àà Set.range (toL2‚Çó k) := by
    intro N
    -- Define the preimage sequence `xN` by dividing the first `N` coordinates by the weight.
    let f : ‚Ñï ‚Üí ‚Ñù := fun n => if n < N then (weight k n)‚Åª¬π * y n else 0
    have hf : ‚àÄ j : ‚Ñï, Mem‚Ñìp (weightFun j f) (2 : ‚Ñù‚â•0‚àû) := by
      intro j
      have hsum :
          Summable (fun n : ‚Ñï => ‚Äñ(weightFun j f) n‚Äñ ^ ((2 : ‚Ñù‚â•0‚àû).toReal)) := by
        refine summable_of_finite_support <| (Set.finite_Iio N).subset ?_
        intro n hn
        have : n < N := by
          by_contra hge
          have hn' : ¬¨ n < N := hge
          have hf0 : f n = 0 := by simp [f, hn']
          have : (weightFun j f) n = 0 := by simp [weightFun, hf0]
          have : (‚Äñ(weightFun j f) n‚Äñ ^ ((2 : ‚Ñù‚â•0‚àû).toReal)) = 0 := by
            simp [this]
          exact hn (by simpa using this)
        exact this
      exact mem‚Ñìp_gen (p := (2 : ‚Ñù‚â•0‚àû)) hsum
    let xN : RapidDecaySeq := ‚ü®f, hf‚ü©
    refine ‚ü®xN, ?_‚ü©
    ext n
    by_cases hn : n < N
    ¬∑ have hne : weight k n ‚â† 0 := by
        have : (n + 1 : ‚Ñù) ‚â† 0 := by exact_mod_cast (Nat.succ_ne_zero n)
        simpa [weight] using (pow_ne_zero k this)
      have : (toL2‚Çó k xN : ‚Ñï ‚Üí ‚Ñù) n = y n := by
        calc
          (toL2‚Çó k xN : ‚Ñï ‚Üí ‚Ñù) n = weight k n * ((weight k n)‚Åª¬π * y n) := by
            simp [toL2‚Çó_apply, xN, f, hn]
          _ = y n := by
            rw [‚Üê mul_assoc (weight k n) (weight k n)‚Åª¬π (y n)]
            simp [hne]
      simp [this, Finset.sum_apply, lp.coeFn_single, Finset.sum_pi_single, Finset.mem_range, hn]
    ¬∑ have hn' : ¬¨ n < N := hn
      have : (toL2‚Çó k xN : ‚Ñï ‚Üí ‚Ñù) n = 0 := by
        simp [toL2‚Çó_apply, xN, f, hn', weightFun]
      simpa [this, Finset.sum_apply, lp.coeFn_single, Finset.sum_pi_single, Finset.mem_range, hn']
  refine mem_closure_of_tendsto hy_tendsto (Filter.Eventually.of_forall h_mem_range)

lemma denseRange_toL2Quot‚Çó (k : ‚Ñï) : DenseRange (toL2Quot‚Çó k) := by
  intro y
  have hy : y ‚àà closure (Set.range (toL2‚Çó k)) := denseRange_toL2‚Çó (k := k) y
  have hrange : Set.range (toL2‚Çó k) = Set.range (toL2Quot‚Çó k) := by
    ext z
    constructor
    ¬∑ rintro ‚ü®x, rfl‚ü©
      refine ‚ü®Submodule.Quotient.mk (p := seminormKer (E := RapidDecaySeq) (p := seminorm k)) x, ?_‚ü©
      simp [toL2Quot‚Çó_mk]
    ¬∑ rintro ‚ü®x, rfl‚ü©
      refine Submodule.Quotient.induction_on
        (p := seminormKer (E := RapidDecaySeq) (p := seminorm k)) x ?_
      intro x
      exact ‚ü®x, by simp [toL2Quot‚Çó_mk]‚ü©
  simpa [hrange] using hy

/-! ### An isometric identification `Banach(seminorm k) ‚âÉ·µ¢ ‚Ñì¬≤` -/

-- Norm preservation for the canonical embedding into the completion.
lemma norm_coe_banachOfSeminorm
    (p : Seminorm ‚Ñù RapidDecaySeq) (x : QuotBySeminorm (E := RapidDecaySeq) p) :
    ‚Äñ(x : BanachOfSeminorm (E := RapidDecaySeq) p)‚Äñ = ‚Äñx‚Äñ := by
  have hIso :
      Isometry ((‚Üë) :
        QuotBySeminorm (E := RapidDecaySeq) p ‚Üí BanachOfSeminorm (E := RapidDecaySeq) p) :=
    UniformSpace.Completion.coe_isometry
  have hdist := hIso.dist_eq x (0 : QuotBySeminorm (E := RapidDecaySeq) p)
  simp [dist_eq_norm]

noncomputable def banachEquivL2 (k : ‚Ñï) :
    BanachOfSeminorm (E := RapidDecaySeq) (seminorm k) ‚âÉ‚Çó·µ¢[‚Ñù] H := by
  -- We work with `E = QuotBySeminorm (seminorm k)` and its linear map into `‚Ñì¬≤`.
  let E : Type := QuotBySeminorm (E := RapidDecaySeq) (seminorm k)
  let T : E ‚Üí‚Çó[‚Ñù] H := toL2Quot‚Çó k
  let F : Submodule ‚Ñù H := LinearMap.range T
  have hTnorm : ‚àÄ x : E, ‚ÄñT x‚Äñ = ‚Äñx‚Äñ := fun x => by simpa [T] using (norm_toL2Quot‚Çó (k := k) x)
  have hTinj : Function.Injective T := by
    intro x y hxy
    have : T (x - y) = 0 := by simp [map_sub, hxy]
    have h0 : ‚ÄñT (x - y)‚Äñ = 0 := by
      simpa using congrArg (fun z : H => ‚Äñz‚Äñ) this
    have hnorm0 : ‚Äñx - y‚Äñ = 0 := by
      calc
        ‚Äñx - y‚Äñ = ‚ÄñT (x - y)‚Äñ := (hTnorm (x - y)).symm
        _ = 0 := h0
    simpa using sub_eq_zero.mp (norm_eq_zero.mp hnorm0)
  let f : E ‚âÉ‚Çó[‚Ñù] F := LinearEquiv.ofInjective T hTinj
  -- Dense embeddings: quotient into its completion, and `F` into `‚Ñì¬≤`.
  let e‚ÇÅ : E ‚Üí‚Çó[‚Ñù] BanachOfSeminorm (E := RapidDecaySeq) (seminorm k) :=
    (BanachOfSeminorm.coeCLM (E := RapidDecaySeq) (seminorm k)).toLinearMap
  let e‚ÇÇ : F ‚Üí‚Çó[‚Ñù] H := (Submodule.subtype F)
  have h_dense‚ÇÅ : DenseRange e‚ÇÅ := by
    simpa [e‚ÇÅ] using (BanachOfSeminorm.denseRange_coeCLM (E := RapidDecaySeq) (p := seminorm k))
  have h_dense‚ÇÇ : DenseRange e‚ÇÇ := by
    have hT_dense : DenseRange T := by simpa [T] using denseRange_toL2Quot‚Çó (k := k)
    intro y
    have : y ‚àà closure (Set.range T) := hT_dense y
    have hrange : Set.range e‚ÇÇ = Set.range T := by
      ext z
      constructor
      ¬∑ rintro ‚ü®u, rfl‚ü©
        simp [e‚ÇÇ]
      ¬∑ rintro ‚ü®x, rfl‚ü©
        exact ‚ü®‚ü®T x, ‚ü®x, rfl‚ü©‚ü©, rfl‚ü©
    simpa [hrange] using this
  have h_norm : ‚àÄ x : E, ‚Äñe‚ÇÇ (f x)‚Äñ = ‚Äñe‚ÇÅ x‚Äñ := by
    intro x
    have hleft : ‚Äñe‚ÇÇ (f x)‚Äñ = ‚ÄñT x‚Äñ := rfl
    have hright : ‚Äñe‚ÇÅ x‚Äñ = ‚Äñx‚Äñ := by
      simp [e‚ÇÅ, BanachOfSeminorm.coeCLM]
    simp [hleft, hright, hTnorm x]
  exact (f.extendOfIsometry (œÉ‚ÇÅ‚ÇÇ := RingHom.id ‚Ñù) e‚ÇÅ e‚ÇÇ h_dense‚ÇÅ h_dense‚ÇÇ h_norm)

@[simp]
lemma banachEquivL2_apply_coe (k : ‚Ñï)
    (x : QuotBySeminorm (E := RapidDecaySeq) (seminorm k)) :
    banachEquivL2 k
        (BanachOfSeminorm.coeCLM (E := RapidDecaySeq) (seminorm k) x) = toL2Quot‚Çó k x := by
  change banachEquivL2 k
        ((‚Üë(BanachOfSeminorm.coeCLM (E := RapidDecaySeq) (seminorm k)) :
            QuotBySeminorm (E := RapidDecaySeq) (seminorm k) ‚Üí‚Çó[‚Ñù]
              BanachOfSeminorm (E := RapidDecaySeq) (seminorm k)) x)
      = toL2Quot‚Çó k x
  simp (config := { zeta := true }) [banachEquivL2]
  have hx :
      (BanachOfSeminorm.coeCLM (E := RapidDecaySeq) (seminorm k) x) =
        ((‚Üë(BanachOfSeminorm.coeCLM (E := RapidDecaySeq) (seminorm k)) :
            QuotBySeminorm (E := RapidDecaySeq) (seminorm k) ‚Üí‚Çó[‚Ñù]
              BanachOfSeminorm (E := RapidDecaySeq) (seminorm k)) x) := rfl
  rw [hx]
  rw [LinearEquiv.extendOfIsometry_eq]
  rfl

/-! ### Nuclearity of the local inclusions -/

-- A key computation: under weights, the inclusion from level `k+2` to level `k` is diagonal.
lemma diagPowInvCLM_two_toL2 (k : ‚Ñï) (x : RapidDecaySeq) :
    diagPowInvCLM 2 (toL2‚Çó (k + 2) x) = toL2‚Çó k x := by
  ext n
  have hn1 : (n + 1 : ‚Ñù) ‚â† 0 := by exact_mod_cast (Nat.succ_ne_zero n)
  have hne2 : weight 2 n ‚â† 0 := by
    simpa [weight] using (pow_ne_zero 2 hn1)
  have hw : weight (k + 2) n = weight k n * weight 2 n := by
    dsimp [weight]
    exact pow_add (n + 1 : ‚Ñù) k 2
  have hcoef : (weight 2 n)‚Åª¬π * weight (k + 2) n = weight k n := by
    rw [hw]
    calc
      (weight 2 n)‚Åª¬π * (weight k n * weight 2 n)
          = ((weight 2 n)‚Åª¬π * weight k n) * weight 2 n := by
              rw [‚Üê mul_assoc]
      _ = (weight k n * (weight 2 n)‚Åª¬π) * weight 2 n := by
            simp [mul_comm]
      _ = weight k n * (weight 2 n)‚Åª¬π * weight 2 n := by
            rw [mul_assoc]
      _ = weight k n := by
            simpa [mul_assoc] using (inv_mul_cancel_right‚ÇÄ (b := weight 2 n) hne2 (a := weight k n))
  have : (weight 2 n)‚Åª¬π * (weight (k + 2) n * x.1 n) = weight k n * x.1 n := by
    rw [‚Üê mul_assoc (weight 2 n)‚Åª¬π (weight (k + 2) n) (x.1 n)]
    rw [hcoef]
  simpa [diagPowInvCLM_apply, toL2‚Çó_apply, sigma, mul_assoc] using this

theorem isNuclearMap_inclCLM_succ_succ (k : ‚Ñï) :
    IsNuclearMap
      (BanachOfSeminorm.inclCLM (E := RapidDecaySeq)
        (p := seminorm (k + 2)) (q := seminorm k)
        (by
          simpa using (seminorm_mono (a := k) (b := k + 2) (Nat.le_add_right k 2)))) := by
  -- Identify the inclusion by conjugating the diagonal nuclear operator on `‚Ñì¬≤`.
  let E‚ÇÄ := BanachOfSeminorm (E := RapidDecaySeq) (seminorm (k + 2))
  let E‚ÇÅ := BanachOfSeminorm (E := RapidDecaySeq) (seminorm k)
  let incl : E‚ÇÄ ‚ÜíL[‚Ñù] E‚ÇÅ :=
    BanachOfSeminorm.inclCLM (E := RapidDecaySeq)
      (p := seminorm (k + 2)) (q := seminorm k)
      (by
        simpa using (seminorm_mono (a := k) (b := k + 2) (Nat.le_add_right k 2)))
  let iso‚ÇÄ : E‚ÇÄ ‚âÉ‚Çó·µ¢[‚Ñù] H := banachEquivL2 (k + 2)
  let iso‚ÇÅ : E‚ÇÅ ‚âÉ‚Çó·µ¢[‚Ñù] H := banachEquivL2 k
  let iso‚ÇÄL : E‚ÇÄ ‚ÜíL[‚Ñù] H := iso‚ÇÄ.toContinuousLinearEquiv.toContinuousLinearMap
  let iso‚ÇÅL : E‚ÇÅ ‚ÜíL[‚Ñù] H := iso‚ÇÅ.toContinuousLinearEquiv.toContinuousLinearMap
  let iso‚ÇÅLinv : H ‚ÜíL[‚Ñù] E‚ÇÅ := iso‚ÇÅ.symm.toContinuousLinearEquiv.toContinuousLinearMap
  have h_conj :
      (iso‚ÇÅL.comp incl) = (diagPowInvCLM 2).comp iso‚ÇÄL := by
    apply ContinuousLinearMap.coeFn_injective
    have hd : DenseRange (BanachOfSeminorm.coeCLM (E := RapidDecaySeq) (seminorm (k + 2))) :=
      BanachOfSeminorm.denseRange_coeCLM (E := RapidDecaySeq) (p := seminorm (k + 2))
    have hs : Dense (Set.range (BanachOfSeminorm.coeCLM (E := RapidDecaySeq) (seminorm (k + 2)))) := by
      refine dense_iff_closure_eq.2 ?_
      exact (denseRange_iff_closure_range).1 hd
    refine Continuous.ext_on hs (by fun_prop) (by fun_prop) ?_
    rintro _ ‚ü®xq, rfl‚ü©
    refine Submodule.Quotient.induction_on (p := seminormKer (E := RapidDecaySeq) (p := seminorm (k + 2))) xq ?_
    intro x
    simp [incl, iso‚ÇÄ, iso‚ÇÅ, iso‚ÇÄL, iso‚ÇÅL]
    rw [BanachOfSeminorm.inclCLM_coeCLM]
    simp [QuotBySeminorm.inclCLM_mk]
    rw [banachEquivL2_apply_coe (k := k) (x := Submodule.Quotient.mk x)]
    rw [banachEquivL2_apply_coe (k := k + 2) (x := Submodule.Quotient.mk x)]
    simp [toL2Quot‚Çó_mk]
    simpa using (diagPowInvCLM_two_toL2 (k := k) (x := x)).symm
  have h_incl :
      incl =
        iso‚ÇÅLinv.comp ((diagPowInvCLM 2).comp iso‚ÇÄL) := by
    calc
      incl = iso‚ÇÅLinv.comp (iso‚ÇÅL.comp incl) := by
        ext y
        simp [iso‚ÇÅLinv, iso‚ÇÅL, ContinuousLinearMap.comp_apply]
      _ = iso‚ÇÅLinv.comp ((diagPowInvCLM 2).comp iso‚ÇÄL) := by
        simpa [ContinuousLinearMap.comp_assoc] using congrArg (fun T => iso‚ÇÅLinv.comp T) h_conj
  have h_diag : IsNuclearMap (diagPowInvCLM 2) :=
    isNuclearMap_diagPowInvCLM (s := 2) (by norm_num)
  have h_diag_pre : IsNuclearMap ((diagPowInvCLM 2).comp iso‚ÇÄL) :=
    IsNuclearMap.comp_right (T := diagPowInvCLM 2) h_diag iso‚ÇÄL
  have h_all :
      IsNuclearMap (iso‚ÇÅLinv.comp ((diagPowInvCLM 2).comp iso‚ÇÄL)) :=
    IsNuclearMap.comp_left (T := (diagPowInvCLM 2).comp iso‚ÇÄL) h_diag_pre iso‚ÇÅLinv
  simpa [incl, ‚Üê h_incl] using h_all

/-! ### The promised `NuclearSpaceStd` instance -/

noncomputable instance : NuclearSpaceStd RapidDecaySeq := by
  refine ‚ü®?_‚ü©
  refine ‚ü®(fun k : ‚Ñï => seminorm k), ?_, withSeminorms, ?_‚ü©
  ¬∑ exact seminorm_mono
  ¬∑ intro k
    refine ‚ü®k + 2, Nat.lt_add_of_pos_right (n := k) (k := 2) (h := by decide), ?_‚ü©
    simpa using (isNuclearMap_inclCLM_succ_succ (k := k))

end RapidDecaySeq

end
end OSforGFF
